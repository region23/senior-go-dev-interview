# Шпаргалка по системному дизайну

## Основные принципы системного дизайна

### Масштабируемость
- **Вертикальное масштабирование (Scale Up)**: увеличение мощности отдельного сервера
- **Горизонтальное масштабирование (Scale Out)**: увеличение количества серверов
- **Автоматическое масштабирование**: динамическое изменение ресурсов в зависимости от нагрузки

### Надежность
- **Отказоустойчивость**: способность системы продолжать работу при отказе компонентов
- **Избыточность**: дублирование критических компонентов
- **Изоляция отказов**: предотвращение каскадных сбоев

### Доступность
- **Высокая доступность (HA)**: минимизация простоев
- **Распределение по зонам доступности**: защита от отказов в дата-центре
- **Распределение по регионам**: защита от региональных сбоев
- **SLA (Service Level Agreement)**: гарантированный уровень доступности
  - 99.9% (три девятки) = 8.76 часов простоя в год
  - 99.99% (четыре девятки) = 52.56 минут простоя в год
  - 99.999% (пять девяток) = 5.26 минут простоя в год

### Производительность
- **Латентность**: время отклика системы
- **Пропускная способность**: количество операций в единицу времени
- **Оптимизация ресурсов**: эффективное использование CPU, памяти, диска, сети

### Безопасность
- **Аутентификация**: проверка подлинности пользователя
- **Авторизация**: проверка прав доступа
- **Шифрование**: защита данных
- **Защита от атак**: DDoS, инъекции, XSS и т.д.

## CAP-теорема

CAP-теорема утверждает, что распределенная система не может одновременно обеспечить все три свойства:

- **Согласованность (Consistency)**: все узлы видят одни и те же данные в один и тот же момент времени
- **Доступность (Availability)**: каждый запрос получает ответ (успешный или неуспешный)
- **Устойчивость к разделению (Partition Tolerance)**: система продолжает работать, несмотря на потерю сообщений между узлами

В реальных системах приходится выбирать два из трех свойств:
- **CP-системы**: жертвуют доступностью ради согласованности (PostgreSQL, ZooKeeper)
- **AP-системы**: жертвуют согласованностью ради доступности (Cassandra, DynamoDB)
- **CA-системы**: работают только в отсутствие разделений (традиционные RDBMS)

## PACELC-теорема

Расширение CAP-теоремы:
- При разделении сети (P) выбор между доступностью (A) и согласованностью (C)
- В остальное время (E) выбор между латентностью (L) и согласованностью (C)

## Базовые компоненты распределенных систем

### Балансировщики нагрузки
- **Распределение запросов**: равномерное распределение нагрузки между серверами
- **Проверка работоспособности**: исключение неработающих серверов
- **Сессионная привязка (Session Affinity)**: направление запросов одного пользователя на один сервер
- **Алгоритмы балансировки**:
  - Round Robin: циклическое распределение
  - Least Connections: сервер с наименьшим количеством соединений
  - IP Hash: распределение на основе хеша IP-адреса
  - Weighted: с учетом мощности серверов

### Кэширование
- **Типы кэширования**:
  - **Клиентское кэширование**: браузер, мобильное приложение
  - **CDN (Content Delivery Network)**: кэширование статического контента
  - **Кэширование на уровне приложения**: Redis, Memcached
  - **Кэширование на уровне базы данных**: кэш запросов, буфер результатов
- **Стратегии инвалидации кэша**:
  - **TTL (Time To Live)**: автоматическое устаревание через определенное время
  - **Write-through**: обновление кэша при записи в БД
  - **Write-behind**: асинхронное обновление БД после записи в кэш
  - **Write-around**: запись в БД в обход кэша
- **Проблемы кэширования**:
  - **Cache Stampede**: множественные запросы к БД при истечении TTL
  - **Thundering Herd**: перегрузка при массовой инвалидации кэша
  - **Cache Penetration**: запросы к несуществующим ключам
  - **Cache Poisoning**: некорректные данные в кэше

### Базы данных
- **Реляционные БД (RDBMS)**:
  - PostgreSQL, MySQL, Oracle
  - ACID-транзакции
  - Нормализация данных
  - SQL-запросы
- **NoSQL БД**:
  - **Key-Value**: Redis, DynamoDB
  - **Document**: MongoDB, CouchDB
  - **Column-Family**: Cassandra, HBase
  - **Graph**: Neo4j, JanusGraph
- **NewSQL**: CockroachDB, Google Spanner
- **Шардирование**: горизонтальное разделение данных
  - **Стратегии шардирования**:
    - По диапазону ключей
    - По хешу ключа
    - По географии
    - По функциональности
- **Репликация**:
  - **Master-Slave**: один мастер для записи, несколько реплик для чтения
  - **Master-Master**: несколько мастеров для записи и чтения
  - **Синхронная**: гарантия согласованности, но выше латентность
  - **Асинхронная**: ниже латентность, но возможна несогласованность

### Очереди сообщений
- **Асинхронная обработка**: разделение отправителя и получателя
- **Буферизация**: сглаживание пиков нагрузки
- **Гарантия доставки**: сохранение сообщений до обработки
- **Примеры**: Kafka, RabbitMQ, Amazon SQS, Google Pub/Sub

### Микросервисы
- **Независимая разработка и развертывание**: каждый сервис развивается отдельно
- **Технологическая независимость**: разные языки и технологии для разных сервисов
- **Изоляция отказов**: сбой одного сервиса не влияет на другие
- **Масштабирование по компонентам**: масштабирование только нужных сервисов
- **Проблемы**:
  - Сложность распределенных транзакций
  - Сложность отладки и мониторинга
  - Сетевые задержки
  - Согласованность данных

### API Gateway
- **Единая точка входа**: маршрутизация запросов к микросервисам
- **Аутентификация и авторизация**: централизованная проверка доступа
- **Ограничение скорости (Rate Limiting)**: защита от перегрузки
- **Трансформация запросов/ответов**: адаптация форматов данных
- **Кэширование**: уменьшение нагрузки на бэкенд
- **Мониторинг**: сбор метрик и логов

### Сервис обнаружения (Service Discovery)
- **Регистрация сервисов**: добавление новых экземпляров
- **Обнаружение сервисов**: поиск доступных экземпляров
- **Проверка работоспособности**: исключение неработающих экземпляров
- **Примеры**: Consul, etcd, ZooKeeper, Eureka

## Шаблоны проектирования распределенных систем

### Шаблоны отказоустойчивости
- **Circuit Breaker (Предохранитель)**: предотвращение каскадных сбоев
  - Закрытое состояние: запросы проходят нормально
  - Открытое состояние: запросы немедленно отклоняются
  - Полуоткрытое состояние: пробные запросы для проверки восстановления
- **Bulkhead (Переборка)**: изоляция ресурсов для предотвращения полного отказа
- **Timeout**: ограничение времени ожидания ответа
- **Retry**: повторные попытки при временных сбоях
- **Fallback**: альтернативное поведение при сбое
- **Rate Limiting**: ограничение количества запросов

### Шаблоны согласованности данных
- **Saga**: координация распределенных транзакций через последовательность локальных транзакций
  - **Хореография**: сервисы обмениваются событиями
  - **Оркестрация**: центральный координатор управляет транзакцией
- **Two-Phase Commit (2PC)**: атомарная фиксация распределенной транзакции
  - Фаза подготовки: все участники готовятся к фиксации
  - Фаза фиксации: все участники фиксируют изменения
- **CQRS (Command Query Responsibility Segregation)**: разделение операций чтения и записи
- **Event Sourcing**: хранение истории изменений вместо текущего состояния

### Шаблоны кэширования
- **Cache-Aside**: приложение управляет взаимодействием с кэшем и БД
- **Read-Through**: кэш автоматически загружает данные из БД при промахе
- **Write-Through**: данные записываются и в кэш, и в БД
- **Write-Behind**: данные сначала записываются в кэш, затем асинхронно в БД
- **Refresh-Ahead**: предварительное обновление часто используемых данных

### Шаблоны масштабирования
- **Sharding**: разделение данных между несколькими БД
- **Read Replicas**: репликация для распределения нагрузки чтения
- **Command and Query Responsibility Segregation (CQRS)**: разделение операций чтения и записи
- **Materialized View**: предварительно вычисленные представления для сложных запросов
- **Compute Grid**: распределение вычислений между несколькими узлами

## Проектирование конкретных систем

### URL-сокращатель (Bit.ly, TinyURL)
- **Компоненты**:
  - API-сервер для создания и редиректа коротких URL
  - База данных для хранения соответствия коротких и длинных URL
  - Кэш для часто используемых URL
- **Алгоритмы генерации коротких URL**:
  - Хеширование с обрезкой (MD5, SHA-256)
  - Инкрементальный счетчик с преобразованием в base62/base64
  - Случайная генерация
- **Масштабирование**:
  - Шардирование БД по диапазону или хешу
  - Репликация для высокой доступности
  - CDN для распределения нагрузки

### Система обработки платежей
- **Компоненты**:
  - API-шлюз для приема запросов
  - Сервис аутентификации и авторизации
  - Сервис обработки платежей
  - Сервис уведомлений
  - База данных для хранения транзакций
  - Очередь сообщений для асинхронной обработки
- **Требования**:
  - Высокая надежность и доступность
  - Атомарность транзакций
  - Безопасность данных
  - Аудит и соответствие нормативам
- **Масштабирование**:
  - Шардирование по ID пользователя или мерчанта
  - Репликация с синхронной записью
  - Горизонтальное масштабирование сервисов

### Поисковая система
- **Компоненты**:
  - Краулер для сбора данных
  - Индексатор для создания поискового индекса
  - Поисковый движок для обработки запросов
  - Ранжирование результатов
  - Кэширование популярных запросов
- **Алгоритмы**:
  - Инвертированный индекс
  - TF-IDF для ранжирования
  - PageRank для определения важности страниц
- **Масштабирование**:
  - Распределенное индексирование
  - Шардирование индекса
  - Репликация для высокой доступности

### Система доставки видеоконтента
- **Компоненты**:
  - Хранилище контента
  - Транскодер для различных форматов и битрейтов
  - CDN для распределения контента
  - API для управления контентом
  - Система рекомендаций
- **Технологии**:
  - Адаптивный битрейт (ABR)
  - Протоколы стриминга (HLS, DASH)
  - Кэширование на разных уровнях
- **Масштабирование**:
  - Географическое распределение CDN
  - Шардирование метаданных
  - Репликация для высокой доступности

### Система уведомлений
- **Компоненты**:
  - API для отправки уведомлений
  - Сервис маршрутизации уведомлений
  - Очереди сообщений для буферизации
  - Сервисы доставки (Push, Email, SMS)
  - База данных для хранения настроек и истории
- **Требования**:
  - Масштабируемость для миллионов пользователей
  - Низкая латентность доставки
  - Гарантия доставки
  - Поддержка различных каналов
- **Масштабирование**:
  - Шардирование по ID пользователя
  - Горизонтальное масштабирование сервисов доставки
  - Очереди с приоритетами

### Социальная сеть
- **Компоненты**:
  - API-шлюз
  - Сервис пользователей
  - Сервис контента (посты, комментарии)
  - Сервис лент (новостная лента, лента активности)
  - Сервис уведомлений
  - Сервис сообщений
  - Хранилище данных (реляционное и NoSQL)
  - Кэш для часто используемых данных
  - CDN для статического контента
- **Проблемы и решения**:
  - **Генерация ленты**:
    - Push-модель: обновление лент при создании поста
    - Pull-модель: генерация ленты при запросе
    - Гибридная модель: комбинация обоих подходов
  - **Масштабирование графа связей**:
    - Шардирование по ID пользователя
    - Кэширование часто запрашиваемых связей
    - Предварительное вычисление рекомендаций
  - **Хранение и доставка медиа**:
    - Объектное хранилище для медиафайлов
    - CDN для распределения нагрузки
    - Транскодирование для различных устройств

## Инструменты для проектирования

### Диаграммы
- **Диаграммы компонентов**: высокоуровневая архитектура системы
- **Диаграммы последовательности**: взаимодействие компонентов во времени
- **Диаграммы потоков данных**: движение данных в системе
- **ER-диаграммы**: структура базы данных

### Оценка нагрузки
- **Количество запросов в секунду (QPS)**: интенсивность трафика
- **Объем данных**: размер хранимых и передаваемых данных
- **Пропускная способность**: количество данных, обрабатываемых в единицу времени
- **Латентность**: время отклика системы

### Оценка ресурсов
- **Вычислительные ресурсы**: CPU, память, диск, сеть
- **Количество серверов**: исходя из нагрузки и требований к доступности
- **Стоимость**: CAPEX и OPEX

## Методология проектирования систем

### Шаги проектирования
1. **Уточнение требований**:
   - Функциональные требования
   - Нефункциональные требования (производительность, масштабируемость, надежность)
   - Ограничения (бюджет, технологии, время)
2. **Оценка масштаба**:
   - Количество пользователей
   - Объем данных
   - Интенсивность запросов
3. **Проектирование API**:
   - Определение интерфейсов
   - Выбор протоколов (REST, GraphQL, gRPC)
   - Форматы данных (JSON, Protocol Buffers)
4. **Проектирование базы данных**:
   - Выбор типа БД (реляционная, NoSQL)
   - Схема данных
   - Стратегия шардирования и репликации
5. **Проектирование высокоуровневой архитектуры**:
   - Компоненты системы
   - Взаимодействие компонентов
   - Потоки данных
6. **Детализация компонентов**:
   - Внутренняя структура каждого компонента
   - Алгоритмы и структуры данных
   - Обработка ошибок
7. **Анализ узких мест**:
   - Идентификация потенциальных проблем
   - Стратегии масштабирования
   - Отказоустойчивость
8. **Оценка ресурсов**:
   - Вычислительные ресурсы
   - Хранилище
   - Сетевая инфраструктура

### Советы для собеседования
- **Структурированный подход**:
  - Следуйте методологии проектирования
  - Четко формулируйте предположения
  - Обосновывайте решения
- **Коммуникация**:
  - Проговаривайте свои мысли вслух
  - Задавайте уточняющие вопросы
  - Используйте диаграммы для иллюстрации
- **Гибкость**:
  - Будьте готовы адаптировать решение при изменении требований
  - Рассматривайте альтернативные подходы
  - Обсуждайте компромиссы

## Примеры вопросов и ответов

### Как спроектировать масштабируемую систему аутентификации?
- **Компоненты**:
  - API-шлюз для приема запросов
  - Сервис аутентификации
  - Сервис управления сессиями
  - База данных пользователей
  - Кэш для токенов и сессий
- **Подходы**:
  - Stateless аутентификация с JWT
  - Stateful аутентификация с сессиями в Redis
  - OAuth 2.0 для федеративной аутентификации
- **Масштабирование**:
  - Шардирование БД пользователей
  - Репликация для высокой доступности
  - Горизонтальное масштабирование сервисов

### Как обеспечить согласованность данных в микросервисной архитектуре?
- **Проблемы**:
  - Распределенные транзакции
  - Временная несогласованность
  - Конфликты при параллельных изменениях
- **Решения**:
  - Saga-паттерн для распределенных транзакций
  - Event Sourcing для отслеживания изменений
  - CQRS для разделения операций чтения и записи
  - Eventual Consistency для асинхронной синхронизации

### Как спроектировать систему, устойчивую к отказам?
- **Стратегии**:
  - Избыточность компонентов
  - Изоляция отказов (Bulkhead)
  - Circuit Breaker для предотвращения каскадных сбоев
  - Graceful Degradation при частичных отказах
  - Автоматическое восстановление
- **Реализация**:
  - Мультизональное развертывание
  - Репликация данных
  - Асинхронная обработка через очереди
  - Мониторинг и автоматическое реагирование

### Как оптимизировать производительность базы данных?
- **Индексирование**:
  - Правильный выбор индексов
  - Покрывающие индексы
  - Индексы для часто используемых запросов
- **Кэширование**:
  - Кэш запросов
  - Кэш результатов
  - Распределенный кэш (Redis, Memcached)
- **Шардирование**:
  - Горизонтальное разделение данных
  - Выбор ключа шардирования
  - Балансировка шардов
- **Оптимизация запросов**:
  - Анализ планов выполнения
  - Денормализация для сложных запросов
  - Материализованные представления

### Как спроектировать систему реального времени?
- **Требования**:
  - Низкая латентность
  - Высокая пропускная способность
  - Устойчивость к пиковым нагрузкам
- **Архитектура**:
  - Event-driven архитектура
  - Потоковая обработка данных
  - In-memory хранение для быстрого доступа
- **Технологии**:
  - WebSockets для двунаправленной связи
  - Kafka для потоковой обработки
  - Redis для in-memory хранения
  - Горизонтальное масштабирование для обработки пиков

## Заключение

Системный дизайн - это искусство балансирования между различными требованиями и ограничениями. Ключевые аспекты, которые следует учитывать:

- **Масштабируемость**: способность системы расти с увеличением нагрузки
- **Надежность**: способность системы корректно функционировать в различных условиях
- **Доступность**: минимизация времени простоя
- **Производительность**: эффективное использование ресурсов
- **Безопасность**: защита данных и функциональности
- **Стоимость**: оптимизация затрат на разработку и эксплуатацию

При проектировании системы важно:
1. Четко понимать требования и ограничения
2. Выбирать подходящие компоненты и технологии
3. Предусматривать возможные проблемы и их решения
4. Обеспечивать возможность эволюции системы со временем
