# Практические примеры системного дизайна

В этом документе представлены подробные примеры проектирования различных систем, которые часто встречаются на технических интервью в компаниях уровня Яндекс и Озон. Каждый пример включает анализ требований, оценку масштаба, высокоуровневый и детальный дизайн, а также обсуждение компромиссов.

## Пример 1: Проектирование поисковой системы

### Требования

**Функциональные требования:**
- Индексация веб-страниц
- Поиск по ключевым словам
- Ранжирование результатов по релевантности
- Автодополнение запросов
- Исправление опечаток

**Нефункциональные требования:**
- Низкая латентность (< 200 мс для поиска)
- Высокая доступность (99.99%)
- Масштабируемость до миллиардов документов
- Актуальность индекса (обновление в течение дня)

### Оценка масштаба

- 1 миллиард веб-страниц в индексе
- Средний размер страницы: 100 КБ
- 100 миллионов поисковых запросов в день
- Пиковая нагрузка: 10,000 запросов в секунду

**Расчеты:**
- Размер индекса: 1B * 100KB = 100TB (сырые данные)
- После сжатия и оптимизации: ~20TB
- QPS: 100M / 86400 ≈ 1,160 (средний), 10,000 (пиковый)

### Высокоуровневый дизайн

**Компоненты системы:**

1. **Краулер (Crawler)**
   - Обходит веб-страницы по ссылкам
   - Следует robots.txt и политикам повторного посещения
   - Распределенная система с очередью URL

2. **Индексатор (Indexer)**
   - Извлекает текст и метаданные из HTML
   - Токенизирует текст
   - Создает инвертированный индекс

3. **Хранилище документов (Document Store)**
   - Хранит оригинальные документы или их сжатые версии
   - Используется для формирования сниппетов

4. **Инвертированный индекс (Inverted Index)**
   - Отображает слова на документы, содержащие их
   - Включает позиции слов и метаданные для ранжирования

5. **Поисковый сервис (Query Service)**
   - Принимает пользовательские запросы
   - Разбирает и оптимизирует запросы
   - Извлекает релевантные документы из индекса
   - Ранжирует результаты

6. **Ранжировщик (Ranker)**
   - Применяет алгоритмы ранжирования (PageRank, ML-модели)
   - Учитывает релевантность, популярность, свежесть

7. **Сервис автодополнения (Autocomplete Service)**
   - Предлагает варианты завершения запроса
   - Использует префиксное дерево (Trie) или другие структуры

8. **Сервис исправления опечаток (Spell Checker)**
   - Предлагает исправления для запросов с ошибками
   - Использует словари и статистические модели

**Диаграмма системы:**
```
[Веб] <---> [Краулер] ---> [Очередь URL] ---> [Индексатор] ---> [Инвертированный индекс]
                                                    |
                                                    v
[Пользователь] <---> [Балансировщик] <---> [Поисковый сервис] <---> [Ранжировщик]
                            |                      ^
                            v                      |
                  [Автодополнение] <---> [Исправление опечаток]
```

### Детальный дизайн

#### 1. Краулер

**Архитектура:**
- Распределенная система с центральным координатором
- Очередь URL с приоритетами
- Политика вежливости (задержки между запросами к одному домену)

**Алгоритм:**
```
function crawl(seed_urls):
    url_queue = PriorityQueue(seed_urls)
    visited = Set()
    
    while not url_queue.empty():
        url = url_queue.dequeue()
        if url in visited or should_skip(url):
            continue
            
        page = download(url)
        visited.add(url)
        store_for_indexing(url, page)
        
        new_urls = extract_urls(page)
        for new_url in new_urls:
            if is_valid(new_url) and not in_visited(new_url):
                url_queue.enqueue(new_url, priority(new_url))
```

**Оптимизации:**
- Распределенное хранение посещенных URL (Bloom-фильтры)
- Инкрементальное обновление индекса
- Приоритизация URL на основе PageRank, свежести, изменений

#### 2. Индексатор

**Процесс индексации:**
1. Извлечение текста из HTML (удаление тегов, скриптов)
2. Токенизация (разбиение на слова)
3. Нормализация (приведение к нижнему регистру, стемминг)
4. Создание инвертированного индекса

**Структура инвертированного индекса:**
```
{
  "слово1": [
    {doc_id: 1, positions: [10, 45, 70], tf: 0.05, ...},
    {doc_id: 5, positions: [3, 18], tf: 0.02, ...},
    ...
  ],
  "слово2": [
    ...
  ]
}
```

**Оптимизации:**
- Сжатие индекса (дельта-кодирование, Elias-Fano)
- Шардирование по словам или документам
- Инкрементальные обновления

#### 3. Поисковый сервис

**Обработка запроса:**
1. Разбор запроса на термы
2. Исправление опечаток и предложение альтернатив
3. Извлечение документов для каждого терма из индекса
4. Пересечение или объединение множеств документов
5. Ранжирование результатов
6. Формирование сниппетов

**Алгоритм поиска:**
```
function search(query):
    terms = tokenize(query)
    corrected_terms = spell_check(terms)
    
    if corrected_terms != terms:
        suggest_correction(corrected_terms)
    
    candidate_docs = []
    for term in terms:
        term_docs = inverted_index.get(term)
        candidate_docs.append(term_docs)
    
    result_docs = intersect(candidate_docs)
    ranked_docs = rank(result_docs, query)
    
    return format_results(ranked_docs)
```

**Оптимизации:**
- Кэширование популярных запросов
- Предварительное вычисление частичных результатов
- Параллельная обработка запросов

#### 4. Ранжирование

**Факторы ранжирования:**
- TF-IDF (частота терма / обратная частота документа)
- Позиции термов в документе
- Близость термов друг к другу
- PageRank или аналогичные метрики авторитетности
- Свежесть документа
- Пользовательские сигналы (CTR, время на странице)

**Алгоритм ранжирования:**
```
function rank(docs, query):
    scored_docs = []
    for doc in docs:
        score = 0
        for term in query:
            term_score = calculate_term_score(doc, term)
            score += term_score
        
        score *= doc.pagerank
        score *= freshness_factor(doc)
        
        scored_docs.append((doc, score))
    
    return sort_by_score(scored_docs)
```

**Оптимизации:**
- Машинное обучение для ранжирования (Learning to Rank)
- Персонализация результатов
- A/B тестирование алгоритмов ранжирования

#### 5. Автодополнение

**Структура данных:**
- Префиксное дерево (Trie) с частотами запросов
- Для каждого префикса хранятся топ-N наиболее популярных запросов

**Алгоритм:**
```
function autocomplete(prefix):
    node = trie.find_node(prefix)
    if not node:
        return []
    
    suggestions = []
    dfs(node, prefix, suggestions)
    
    return sort_by_frequency(suggestions)[:10]

function dfs(node, current_prefix, suggestions):
    if node.is_end_of_query:
        suggestions.append((current_prefix, node.frequency))
    
    for child in node.children:
        dfs(child, current_prefix + child.char, suggestions)
```

**Оптимизации:**
- Предварительное вычисление топ-N для каждого префикса
- Персонализация на основе истории пользователя
- Распределенное хранение Trie с шардированием по префиксам

### Обсуждение компромиссов

**Свежесть vs Масштаб:**
- Полное переиндексирование требует значительных ресурсов
- Инкрементальное обновление может привести к несогласованности
- Решение: многоуровневая индексация (частые обновления для важных сайтов)

**Латентность vs Полнота:**
- Поиск по всему индексу может быть медленным
- Ограничение поиска может пропустить релевантные результаты
- Решение: параллельный поиск, ранняя остановка, кэширование

**Точность vs Покрытие:**
- Строгое соответствие может пропустить релевантные документы
- Нечеткое соответствие может включить нерелевантные результаты
- Решение: комбинированный подход с различными весами

**Хранение vs Вычисление:**
- Предварительное вычисление ускоряет поиск, но требует больше хранилища
- Вычисление на лету экономит хранилище, но увеличивает латентность
- Решение: гибридный подход с кэшированием популярных запросов

## Пример 2: Проектирование системы обработки платежей

### Требования

**Функциональные требования:**
- Обработка платежей с кредитных карт, электронных кошельков и банковских переводов
- Проверка платежей на мошенничество
- Управление возвратами и спорами
- Генерация отчетов и аналитика
- Интеграция с внешними платежными системами

**Нефункциональные требования:**
- Высокая надежность (99.999% доступность)
- Низкая латентность (< 1 секунды для авторизации)
- Безопасность и соответствие стандартам (PCI DSS)
- Масштабируемость до миллионов транзакций в день
- Согласованность данных (особенно для финансовых операций)

### Оценка масштаба

- 10 миллионов пользователей
- 1 миллион транзакций в день
- Средний размер транзакции: 1 КБ
- Пиковая нагрузка: 100 транзакций в секунду

**Расчеты:**
- Хранилище транзакций: 1M * 1KB * 365 * 5 лет = 1.8TB
- QPS: 1M / 86400 ≈ 12 (средний), 100 (пиковый)
- Пропускная способность: 100 TPS * 1KB = 100KB/s

### Высокоуровневый дизайн

**Компоненты системы:**

1. **API Gateway**
   - Принимает запросы на платежи
   - Аутентификация и авторизация
   - Маршрутизация запросов

2. **Платежный сервис (Payment Service)**
   - Валидация платежной информации
   - Маршрутизация к соответствующим платежным процессорам
   - Управление статусом транзакций

3. **Сервис проверки мошенничества (Fraud Detection)**
   - Анализ транзакций на подозрительную активность
   - Блокировка потенциально мошеннических операций
   - Машинное обучение для выявления паттернов мошенничества

4. **Платежные процессоры (Payment Processors)**
   - Интеграция с банками и платежными системами
   - Обработка различных типов платежей
   - Управление ответами от платежных систем

5. **Сервис учета (Ledger Service)**
   - Запись всех финансовых операций
   - Обеспечение согласованности и аудита
   - Расчет балансов и комиссий

6. **Сервис возвратов и споров (Refund & Dispute Service)**
   - Обработка запросов на возврат
   - Управление спорными ситуациями
   - Коммуникация с платежными системами для возвратов

7. **Сервис уведомлений (Notification Service)**
   - Отправка уведомлений о статусе платежей
   - Интеграция с email, SMS, push-уведомлениями
   - Управление шаблонами уведомлений

8. **Сервис отчетов и аналитики (Reporting & Analytics)**
   - Генерация финансовых отчетов
   - Аналитика транзакций и трендов
   - Дашборды для мониторинга

**Диаграмма системы:**
```
[Клиент] <---> [API Gateway] <---> [Платежный сервис] <---> [Платежные процессоры] <---> [Банки/Платежные системы]
                    |                      |
                    v                      v
            [Аутентификация]     [Проверка мошенничества]
                                          |
                                          v
                                  [Сервис учета] <---> [База данных транзакций]
                                          |
                                          v
                              [Сервис возвратов и споров]
                                          |
                                          v
                                [Сервис уведомлений] ---> [Email/SMS/Push]
                                          |
                                          v
                              [Сервис отчетов и аналитики]
```

### Детальный дизайн

#### 1. Платежный сервис

**Процесс обработки платежа:**
1. Валидация платежной информации
2. Проверка на мошенничество
3. Маршрутизация к соответствующему процессору
4. Обработка ответа от процессора
5. Запись транзакции в сервис учета
6. Отправка уведомления о результате

**Состояния транзакции:**
- `INITIATED` - транзакция создана
- `PENDING` - ожидание ответа от платежной системы
- `AUTHORIZED` - платеж авторизован, но не завершен
- `CAPTURED` - средства списаны
- `FAILED` - транзакция не удалась
- `REFUNDED` - средства возвращены
- `DISPUTED` - транзакция оспаривается

**Обработка ошибок:**
- Повторные попытки для временных сбоев
- Fallback на альтернативные платежные методы
- Асинхронное обновление статуса для длительных операций

#### 2. Сервис проверки мошенничества

**Факторы риска:**
- Несоответствие адреса доставки и биллинга
- Необычно большие суммы
- Высокая частота транзакций
- Географические аномалии
- История мошенничества

**Алгоритм проверки:**
```
function check_fraud(transaction, user):
    risk_score = 0
    
    # Проверка истории пользователя
    if user.is_new or user.has_fraud_history:
        risk_score += 50
    
    # Проверка суммы
    if transaction.amount > user.avg_transaction * 3:
        risk_score += 30
    
    # Проверка геолокации
    if transaction.country != user.usual_country:
        risk_score += 40
    
    # Проверка частоты
    if user.transactions_last_hour > 5:
        risk_score += 20
    
    if risk_score > THRESHOLD:
        return REJECT
    elif risk_score > WARNING_THRESHOLD:
        return REVIEW
    else:
        return APPROVE
```

**Оптимизации:**
- Машинное обучение для адаптивной оценки риска
- Реальновременный мониторинг паттернов мошенничества
- Интеграция с внешними сервисами проверки мошенничества

#### 3. Сервис учета

**Структура данных:**
```
Transaction {
    id: UUID,
    user_id: UUID,
    amount: Decimal,
    currency: String,
    payment_method: {
        type: String,  // CARD, WALLET, BANK_TRANSFER
        details: Object  // Зашифрованные детали платежа
    },
    status: String,
    created_at: Timestamp,
    updated_at: Timestamp,
    metadata: Object
}

Ledger {
    id: UUID,
    transaction_id: UUID,
    type: String,  // DEBIT, CREDIT
    amount: Decimal,
    currency: String,
    account_id: UUID,
    created_at: Timestamp
}
```

**Обеспечение согласованности:**
- Транзакции в базе данных для атомарных операций
- Двойная запись (double-entry) для финансовых операций
- Периодическая сверка (reconciliation)

**Шардирование данных:**
- По пользователю или мерчанту
- По временным периодам
- Архивирование старых транзакций

#### 4. Безопасность и соответствие стандартам

**Защита данных:**
- Шифрование данных карт (в покое и при передаче)
- Токенизация платежных данных
- Ограниченный доступ к чувствительной информации

**Соответствие PCI DSS:**
- Сегментация сети
- Строгий контроль доступа
- Регулярные аудиты безопасности
- Логирование и мониторинг

**Защита от атак:**
- Защита от DDoS
- Ограничение частоты запросов (rate limiting)
- WAF (Web Application Firewall)
- Мониторинг подозрительной активности

### Обсуждение компромиссов

**Доступность vs Согласованность:**
- Финансовые системы требуют строгой согласованности
- Высокая доступность необходима для бизнес-операций
- Решение: использование баз данных с сильной согласованностью (PostgreSQL) с репликацией

**Безопасность vs Удобство:**
- Строгие меры безопасности могут усложнить пользовательский опыт
- Упрощение процесса может создать уязвимости
- Решение: многоуровневая защита с адаптивной проверкой риска

**Производительность vs Полнота проверки:**
- Тщательная проверка мошенничества увеличивает время обработки
- Быстрая обработка может пропустить мошеннические операции
- Решение: асинхронная проверка с предварительной авторизацией

**Внутренняя разработка vs Интеграция:**
- Разработка собственных платежных процессоров дает контроль
- Интеграция с существующими решениями ускоряет выход на рынок
- Решение: гибридный подход с собственной платформой и интеграциями

## Пример 3: Проектирование системы доставки видеоконтента (Video Streaming)

### Требования

**Функциональные требования:**
- Загрузка и хранение видеофайлов
- Транскодирование видео в различные форматы и качество
- Потоковая передача видео пользователям
- Адаптивный битрейт в зависимости от качества соединения
- Поддержка различных устройств (мобильные, десктоп, Smart TV)
- Аналитика просмотров

**Нефункциональные требования:**
- Низкая задержка при начале воспроизведения (< 2 секунды)
- Высокая доступность (99.9%)
- Масштабируемость до миллионов одновременных зрителей
- Глобальное распределение контента
- Защита контента от несанкционированного доступа

### Оценка масштаба

- 50 миллионов пользователей
- 1 миллион одновременных зрителей в пиковые часы
- 100,000 часов нового видеоконтента в месяц
- Средняя продолжительность просмотра: 30 минут
- Средний битрейт: 3 Mbps (HD качество)

**Расчеты:**
- Хранилище: 100,000 часов * 3600 секунд * 3 Mbps / 8 = 135 TB/месяц
- Пропускная способность: 1M зрителей * 3 Mbps = 3 Tbps
- Ежедневный трафик: 1M * 30 минут * 3 Mbps * 24 часа / 8 = 270 PB/день

### Высокоуровневый дизайн

**Компоненты системы:**

1. **Сервис загрузки (Upload Service)**
   - Прием видеофайлов от создателей контента
   - Валидация форматов и метаданных
   - Временное хранение для обработки

2. **Сервис транскодирования (Transcoding Service)**
   - Конвертация видео в различные форматы (HLS, DASH)
   - Создание версий с разным качеством (240p, 360p, 480p, 720p, 1080p)
   - Оптимизация для различных устройств

3. **Хранилище видео (Video Storage)**
   - Долгосрочное хранение оригинальных и транскодированных файлов
   - Распределенная файловая система
   - Репликация для надежности

4. **CDN (Content Delivery Network)**
   - Глобальное распределение контента
   - Кэширование популярных видео
   - Оптимизация маршрутизации для минимизации задержек

5. **Сервис потоковой передачи (Streaming Service)**
   - Обработка запросов на воспроизведение
   - Аутентификация и авторизация
   - Маршрутизация к ближайшему CDN

6. **Сервис метаданных (Metadata Service)**
   - Хранение информации о видео (название, описание, теги)
   - Поиск и рекомендации
   - Управление правами доступа

7. **Сервис аналитики (Analytics Service)**
   - Сбор данных о просмотрах
   - Анализ популярности контента
   - Мониторинг качества воспроизведения

**Диаграмма системы:**
```
[Создатель контента] ---> [Сервис загрузки] ---> [Сервис транскодирования] ---> [Хранилище видео]
                                                                                      |
                                                                                      v
[Пользователь] <---> [Балансировщик] <---> [Сервис потоковой передачи] <---> [CDN] <---
                            |                         |
                            v                         v
                  [Сервис метаданных] <---> [Сервис аналитики]
```

### Детальный дизайн

#### 1. Сервис загрузки и транскодирования

**Процесс загрузки:**
1. Создатель загружает видео через веб-интерфейс или API
2. Файл проверяется на вирусы и валидность формата
3. Видео сохраняется во временное хранилище
4. Создается задача на транскодирование
5. Метаданные сохраняются в сервисе метаданных

**Процесс транскодирования:**
1. Видео разбивается на сегменты для параллельной обработки
2. Каждый сегмент транскодируется в различные форматы и качество
3. Сегменты объединяются и создаются манифест-файлы (HLS, DASH)
4. Транскодированные файлы загружаются в постоянное хранилище
5. CDN уведомляется о новом контенте

**Архитектура транскодирования:**
```
function transcode(video_id, formats):
    video = storage.get(video_id)
    segments = split_into_segments(video)
    
    transcoded_segments = {}
    for format in formats:
        transcoded_segments[format] = []
        for segment in segments:
            task = transcode_worker.submit(segment, format)
            transcoded_segments[format].append(task)
    
    # Ожидание завершения всех задач
    for format in formats:
        wait_all(transcoded_segments[format])
        
    # Объединение сегментов и создание манифестов
    for format in formats:
        merged_video = merge_segments(transcoded_segments[format])
        manifest = create_manifest(merged_video, format)
        
        storage.store(f"{video_id}/{format}/video", merged_video)
        storage.store(f"{video_id}/{format}/manifest", manifest)
    
    # Уведомление CDN
    cdn.invalidate(video_id)
```

**Оптимизации:**
- Очередь задач для балансировки нагрузки
- Приоритизация популярного контента
- Предварительное транскодирование для часто запрашиваемых форматов

#### 2. Хранение и доставка контента

**Структура хранилища:**
- Оригинальные файлы хранятся в долгосрочном хранилище (S3, GCS)
- Транскодированные файлы организованы по ID видео, формату и качеству
- Метаданные хранятся в базе данных (PostgreSQL, MongoDB)

**CDN архитектура:**
- Глобальная сеть точек присутствия (PoP)
- Иерархическое кэширование (Edge -> Regional -> Origin)
- Динамическая маршрутизация на основе геолокации и нагрузки

**Протоколы потоковой передачи:**
- HLS (HTTP Live Streaming) для iOS и большинства браузеров
- DASH (Dynamic Adaptive Streaming over HTTP) для Android и Smart TV
- Сегментированные файлы (обычно 2-10 секунд) для адаптивного битрейта

#### 3. Сервис потоковой передачи

**Процесс воспроизведения:**
1. Пользователь запрашивает видео через приложение или браузер
2. Запрос проходит аутентификацию и авторизацию
3. Сервис определяет ближайший CDN для пользователя
4. Клиент получает URL для манифест-файла
5. Клиент загружает манифест и начинает запрашивать сегменты
6. Адаптивный битрейт автоматически регулирует качество в зависимости от сети

**Адаптивный битрейт:**
```
function adaptive_bitrate(client_bandwidth, available_qualities):
    # Начинаем с низкого качества для быстрого старта
    current_quality = min(available_qualities)
    
    # Периодически проверяем и адаптируем
    while video_is_playing:
        measured_bandwidth = measure_client_bandwidth()
        buffer_level = get_buffer_level()
        
        # Выбираем качество на основе пропускной способности и буфера
        target_quality = select_quality(measured_bandwidth, buffer_level, available_qualities)
        
        if target_quality != current_quality:
            switch_quality(target_quality)
            current_quality = target_quality
            
        sleep(ADAPTATION_INTERVAL)
```

**Оптимизации:**
- Предварительная загрузка (preloading) популярного контента
- Адаптивная буферизация
- Прогрессивная загрузка для быстрого старта

#### 4. Защита контента

**DRM (Digital Rights Management):**
- Интеграция с системами DRM (Widevine, PlayReady, FairPlay)
- Шифрование контента
- Управление лицензиями

**Защита от несанкционированного доступа:**
- Подписанные URL с ограниченным временем жизни
- Токены доступа
- Географические ограничения

**Защита от скачивания:**
- Сегментирование контента
- Шифрование на уровне транспорта
- Обфускация URL

### Обсуждение компромиссов

**Качество vs Доступность:**
- Высокое качество требует большей пропускной способности
- Низкое качество ухудшает пользовательский опыт
- Решение: адаптивный битрейт с приоритетом на непрерывность воспроизведения

**Задержка vs Буферизация:**
- Малая задержка может привести к частым остановкам
- Большая буферизация увеличивает время начала воспроизведения
- Решение: адаптивная буферизация на основе стабильности соединения

**Хранение vs Транскодирование на лету:**
- Предварительное транскодирование требует больше хранилища
- Транскодирование на лету увеличивает задержку
- Решение: гибридный подход с предварительным транскодированием популярного контента

**Централизация vs Распределение:**
- Централизованное хранение упрощает управление
- Распределенное хранение улучшает доступность и производительность
- Решение: многоуровневая архитектура с централизованным управлением и распределенным хранением

## Пример 4: Проектирование системы уведомлений

### Требования

**Функциональные требования:**
- Отправка уведомлений через различные каналы (push, email, SMS, in-app)
- Персонализация уведомлений
- Планирование уведомлений на определенное время
- Группировка и приоритизация уведомлений
- Отслеживание доставки и открытия уведомлений

**Нефункциональные требования:**
- Высокая пропускная способность (миллионы уведомлений в час)
- Низкая задержка для критичных уведомлений (< 5 секунд)
- Надежность доставки (at-least-once semantics)
- Масштабируемость для пиковых нагрузок
- Устойчивость к сбоям внешних сервисов

### Оценка масштаба

- 50 миллионов пользователей
- В среднем 5 уведомлений на пользователя в день
- Пиковая нагрузка: 1 миллион уведомлений в минуту
- Размер уведомления: ~1 КБ

**Расчеты:**
- Ежедневные уведомления: 50M * 5 = 250M
- QPS (средний): 250M / 86400 ≈ 2,900
- QPS (пиковый): 1M / 60 ≈ 16,700
- Хранилище (ежедневное): 250M * 1KB = 250GB

### Высокоуровневый дизайн

**Компоненты системы:**

1. **API Gateway**
   - Принимает запросы на отправку уведомлений
   - Валидация и аутентификация
   - Маршрутизация запросов

2. **Сервис уведомлений (Notification Service)**
   - Обработка запросов на уведомления
   - Персонализация контента
   - Маршрутизация по каналам

3. **Очередь сообщений (Message Queue)**
   - Буферизация уведомлений
   - Обеспечение надежности доставки
   - Балансировка нагрузки

4. **Обработчики каналов (Channel Handlers)**
   - Push-уведомления (FCM, APNS)
   - Email (SMTP)
   - SMS (Twilio, Nexmo)
   - In-app уведомления

5. **Планировщик (Scheduler)**
   - Планирование отложенных уведомлений
   - Периодические уведомления
   - Управление временными зонами

6. **Сервис шаблонов (Template Service)**
   - Управление шаблонами уведомлений
   - Локализация
   - Персонализация

7. **Сервис отслеживания (Tracking Service)**
   - Мониторинг доставки
   - Отслеживание открытий и взаимодействий
   - Аналитика эффективности

8. **Сервис предпочтений (Preference Service)**
   - Управление пользовательскими настройками
   - Отписка и частота уведомлений
   - Правила не беспокоить (DND)

**Диаграмма системы:**
```
[Клиент/Сервис] ---> [API Gateway] ---> [Сервис уведомлений] ---> [Очередь сообщений]
                                              |                           |
                                              v                           v
                                     [Сервис шаблонов]        [Обработчики каналов] ---> [Внешние сервисы]
                                              |                           |                     |
                                              v                           v                     v
                                    [Сервис предпочтений] <--- [Сервис отслеживания] <--- [Пользователи]
                                              ^
                                              |
                                        [Планировщик]
```

### Детальный дизайн

#### 1. Сервис уведомлений

**Процесс обработки уведомления:**
1. Получение запроса на отправку уведомления
2. Проверка прав доступа и валидация
3. Получение информации о пользователе и его предпочтениях
4. Применение шаблона и персонализация
5. Определение каналов доставки
6. Отправка в соответствующие очереди

**Структура запроса:**
```json
{
  "notification_id": "uuid",
  "recipients": ["user_id1", "user_id2", ...],
  "template_id": "welcome_template",
  "channels": ["push", "email"],
  "data": {
    "user_name": "{{user.name}}",
    "product_name": "Product X"
  },
  "priority": "high",
  "scheduled_at": "2023-05-01T10:00:00Z",
  "ttl": 3600
}
```

**Оптимизации:**
- Батчинг уведомлений для одного шаблона
- Приоритизация критичных уведомлений
- Дедупликация для избежания спама

#### 2. Система очередей

**Архитектура очередей:**
- Отдельные очереди для каждого канала
- Приоритетные очереди для срочных уведомлений
- Dead Letter Queue (DLQ) для неудачных попыток

**Обработка сообщений:**
```
function process_queue(channel):
    while True:
        messages = queue.receive_batch(channel, max_batch_size=100)
        
        for message in messages:
            try:
                result = channel_handler.send(message)
                if result.success:
                    queue.delete(message)
                    tracking_service.record_delivery(message.id)
                else:
                    handle_failure(message, result.error)
            except Exception as e:
                handle_failure(message, e)

function handle_failure(message, error):
    message.retry_count += 1
    
    if message.retry_count < MAX_RETRIES:
        # Экспоненциальная задержка
        delay = BASE_DELAY * (2 ** message.retry_count)
        queue.requeue(message, delay=delay)
    else:
        # Перемещение в DLQ
        dead_letter_queue.send(message, error=error)
        tracking_service.record_failure(message.id, error)
```

**Надежность:**
- At-least-once семантика с идемпотентностью
- Экспоненциальная задержка для повторных попыток
- Мониторинг и алерты для DLQ

#### 3. Обработчики каналов

**Push-уведомления:**
- Интеграция с FCM (Firebase Cloud Messaging) для Android
- Интеграция с APNS (Apple Push Notification Service) для iOS
- Управление токенами устройств
- Обработка ответов от push-сервисов

**Email:**
- Интеграция с SMTP-серверами или сервисами (SendGrid, Mailgun)
- Управление репутацией отправителя
- Обработка отказов и жалоб на спам
- Отслеживание открытий и кликов

**SMS:**
- Интеграция с SMS-провайдерами (Twilio, Nexmo)
- Оптимизация затрат с учетом региональных особенностей
- Соблюдение регуляторных требований
- Управление ограничениями на частоту

**In-app уведомления:**
- Хранение в базе данных
- Доставка через WebSocket или long polling
- Управление статусом (прочитано/не прочитано)
- Группировка и сортировка

#### 4. Планировщик и персонализация

**Планировщик:**
- Хранение запланированных уведомлений в базе данных
- Периодическое сканирование для выявления готовых к отправке
- Обработка часовых поясов пользователей
- Рекуррентные уведомления (ежедневные, еженедельные)

**Персонализация:**
- Шаблонизация с поддержкой переменных
- Локализация на основе языка пользователя
- A/B тестирование различных вариантов
- Персонализация на основе пользовательского поведения

#### 5. Отслеживание и аналитика

**Отслеживание доставки:**
- Запись статусов доставки (отправлено, доставлено, открыто)
- Отслеживание кликов по ссылкам
- Мониторинг конверсии (действия после уведомления)

**Аналитика:**
- Эффективность каналов
- Оптимальное время отправки
- Анализ отписок и причин
- Сегментация пользователей по отклику

### Обсуждение компромиссов

**Надежность vs Задержка:**
- Гарантированная доставка требует подтверждений и повторных попыток
- Низкая задержка может потребовать компромиссов в надежности
- Решение: многоуровневая система с разными гарантиями для разных приоритетов

**Масштабируемость vs Стоимость:**
- Обработка пиковых нагрузок требует избыточных ресурсов
- Оптимизация затрат может ограничить пропускную способность
- Решение: автомасштабирование и приоритизация критичных уведомлений

**Персонализация vs Производительность:**
- Глубокая персонализация требует доступа к данным пользователя
- Высокая производительность требует минимизации зависимостей
- Решение: кэширование данных пользователя и асинхронная персонализация

**Централизация vs Модульность:**
- Единая система упрощает управление
- Модульная архитектура улучшает масштабируемость и изоляцию
- Решение: микросервисная архитектура с централизованным мониторингом

## Заключение

В этом документе мы рассмотрели четыре примера проектирования систем, которые часто встречаются на технических интервью:

1. **Поисковая система** - сложная распределенная система с фокусом на масштабируемость и производительность
2. **Система обработки платежей** - критичная финансовая система с акцентом на надежность и безопасность
3. **Система доставки видеоконтента** - глобальная система с высокими требованиями к пропускной способности
4. **Система уведомлений** - высоконагруженная система реального времени с множеством внешних интеграций

Каждый пример включает:
- Анализ функциональных и нефункциональных требований
- Оценку масштаба системы
- Высокоуровневый и детальный дизайн
- Обсуждение компромиссов и альтернативных подходов

При подготовке к интервью по системному дизайну важно:
1. Структурированно подходить к решению задачи
2. Четко формулировать требования и ограничения
3. Обосновывать архитектурные решения
4. Анализировать компромиссы и альтернативы
5. Демонстрировать понимание масштабируемости, надежности и производительности

Эти примеры могут служить шаблонами для решения подобных задач на интервью, но помните, что важно адаптировать решение под конкретные требования и ограничения задачи.
