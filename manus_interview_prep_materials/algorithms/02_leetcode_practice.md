# Практика решения задач LeetCode для технического интервью

## Введение

В этом руководстве мы рассмотрим типичные задачи с LeetCode, которые часто встречаются на технических интервью в компаниях уровня Яндекс и Озон. Для каждой задачи будет представлено подробное решение на Go с объяснением подхода, анализом сложности и ключевыми моментами, на которые стоит обратить внимание.

## Стратегия решения задач на LeetCode

### Подготовка к интервью

1. **Регулярная практика**: Решайте 1-2 задачи каждый день
2. **Разнообразие тем**: Охватите все основные типы задач (массивы, строки, деревья, графы, ДП)
3. **Постепенное усложнение**: Начните с Easy, затем переходите к Medium
4. **Анализ решений**: После решения изучите другие подходы и оптимизации
5. **Повторение**: Возвращайтесь к решенным задачам через некоторое время

### Процесс решения задачи на интервью

1. **Понимание задачи**:
   - Внимательно прочитайте условие
   - Задайте уточняющие вопросы
   - Проговорите вслух свое понимание задачи
   - Обсудите входные и выходные данные, ограничения

2. **Разработка подхода**:
   - Начните с простых примеров
   - Рассмотрите граничные случаи
   - Подумайте вслух о возможных подходах
   - Выберите наиболее подходящий алгоритм

3. **Анализ сложности**:
   - Оцените временную и пространственную сложность
   - Обсудите возможные оптимизации

4. **Реализация**:
   - Пишите чистый, понятный код
   - Используйте осмысленные имена переменных
   - Комментируйте сложные части

5. **Тестирование**:
   - Проверьте решение на простых примерах
   - Рассмотрите граничные случаи
   - Отладьте код при необходимости

## Задачи уровня Easy

### 1. Two Sum (Два числа)

**Задача**: Дан массив целых чисел `nums` и целое число `target`. Верните индексы двух чисел из массива, сумма которых равна `target`.

**Пример**:
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: nums[0] + nums[1] = 2 + 7 = 9
```

**Решение**:
```go
func twoSum(nums []int, target int) []int {
    // Создаем карту для хранения чисел и их индексов
    numMap := make(map[int]int)
    
    // Проходим по массиву
    for i, num := range nums {
        // Вычисляем дополнение до target
        complement := target - num
        
        // Проверяем, есть ли дополнение в карте
        if idx, found := numMap[complement]; found {
            return []int{idx, i}
        }
        
        // Добавляем текущее число и его индекс в карту
        numMap[num] = i
    }
    
    // Если решение не найдено
    return nil
}
```

**Анализ**:
- **Временная сложность**: O(n) - один проход по массиву
- **Пространственная сложность**: O(n) - для хранения карты

**Ключевые моменты**:
- Использование хеш-таблицы (map) для быстрого поиска
- Проверка наличия дополнения до target на каждом шаге
- Обработка случая, когда решение не найдено

### 2. Valid Parentheses (Правильные скобки)

**Задача**: Дана строка `s`, содержащая только символы '(', ')', '{', '}', '[' и ']'. Определите, является ли строка правильной скобочной последовательностью.

**Пример**:
```
Input: s = "()[]{}"
Output: true

Input: s = "([)]"
Output: false
```

**Решение**:
```go
func isValid(s string) bool {
    // Создаем стек для хранения открывающих скобок
    stack := []rune{}
    
    // Карта соответствия закрывающих скобок открывающим
    brackets := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    
    // Проходим по строке
    for _, char := range s {
        // Если это закрывающая скобка
        if opening, found := brackets[char]; found {
            // Проверяем, соответствует ли она последней открывающей скобке
            if len(stack) == 0 || stack[len(stack)-1] != opening {
                return false
            }
            // Удаляем соответствующую открывающую скобку из стека
            stack = stack[:len(stack)-1]
        } else {
            // Если это открывающая скобка, добавляем ее в стек
            stack = append(stack, char)
        }
    }
    
    // Строка правильная, если стек пуст
    return len(stack) == 0
}
```

**Анализ**:
- **Временная сложность**: O(n) - один проход по строке
- **Пространственная сложность**: O(n) - для хранения стека

**Ключевые моменты**:
- Использование стека для отслеживания открывающих скобок
- Проверка соответствия закрывающих скобок последним открывающим
- Строка правильная только если все открывающие скобки имеют соответствующие закрывающие

### 3. Merge Two Sorted Lists (Объединение двух отсортированных списков)

**Задача**: Даны головы двух отсортированных связных списков `list1` и `list2`. Объедините их в один отсортированный список и верните его голову.

**Пример**:
```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Решение**:
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    // Создаем фиктивный узел в качестве начала результирующего списка
    dummy := &ListNode{}
    current := dummy
    
    // Пока оба списка не пусты
    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val {
            current.Next = list1
            list1 = list1.Next
        } else {
            current.Next = list2
            list2 = list2.Next
        }
        current = current.Next
    }
    
    // Добавляем оставшиеся элементы
    if list1 != nil {
        current.Next = list1
    } else {
        current.Next = list2
    }
    
    return dummy.Next
}
```

**Анализ**:
- **Временная сложность**: O(n + m) - где n и m - длины списков
- **Пространственная сложность**: O(1) - используем только указатели

**Ключевые моменты**:
- Использование фиктивного узла для упрощения обработки
- Последовательное сравнение элементов обоих списков
- Обработка оставшихся элементов после завершения одного из списков

### 4. Maximum Subarray (Максимальный подмассив)

**Задача**: Дан целочисленный массив `nums`. Найдите подмассив с наибольшей суммой и верните эту сумму.

**Пример**:
```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: Подмассив [4,-1,2,1] имеет наибольшую сумму 6.
```

**Решение** (алгоритм Кадане):
```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    // Инициализируем переменные для отслеживания максимальной суммы
    maxSoFar := nums[0]
    maxEndingHere := nums[0]
    
    // Проходим по массиву, начиная со второго элемента
    for i := 1; i < len(nums); i++ {
        // Выбираем лучшее: начать новый подмассив или продолжить текущий
        maxEndingHere = max(nums[i], maxEndingHere+nums[i])
        
        // Обновляем глобальный максимум
        maxSoFar = max(maxSoFar, maxEndingHere)
    }
    
    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**Анализ**:
- **Временная сложность**: O(n) - один проход по массиву
- **Пространственная сложность**: O(1) - используем только переменные

**Ключевые моменты**:
- Использование алгоритма Кадане для нахождения максимального подмассива
- На каждом шаге решаем: начать новый подмассив или продолжить текущий
- Отслеживаем глобальный максимум на протяжении всего алгоритма

### 5. Climbing Stairs (Подъем по лестнице)

**Задача**: Вы поднимаетесь по лестнице. Требуется n шагов, чтобы достичь вершины. Каждый раз вы можете подняться на 1 или 2 ступеньки. Сколькими различными способами вы можете подняться на вершину?

**Пример**:
```
Input: n = 3
Output: 3
Explanation: Есть три способа подняться на вершину:
1. 1 шаг + 1 шаг + 1 шаг
2. 1 шаг + 2 шага
3. 2 шага + 1 шаг
```

**Решение** (динамическое программирование):
```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    
    // Инициализируем массив для хранения количества способов
    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2
    
    // Заполняем массив
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    return dp[n]
}
```

**Оптимизированное решение** (с константной памятью):
```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    
    // Используем только две переменные вместо массива
    prev1 := 1
    prev2 := 2
    
    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev1 = prev2
        prev2 = current
    }
    
    return prev2
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1) для оптимизированного решения

**Ключевые моменты**:
- Это классическая задача на динамическое программирование
- Рекуррентное соотношение: dp[i] = dp[i-1] + dp[i-2]
- Фактически, это последовательность Фибоначчи, начиная с 1 и 2
- Можно оптимизировать пространственную сложность до O(1)

## Задачи уровня Medium

### 1. Add Two Numbers (Сложение двух чисел)

**Задача**: Даны два непустых связных списка, представляющих два неотрицательных целых числа. Цифры хранятся в обратном порядке, и каждый узел содержит одну цифру. Сложите два числа и верните сумму в виде связного списка.

**Пример**:
```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```

**Решение**:
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0
    
    // Пока есть узлы в любом из списков или перенос
    for l1 != nil || l2 != nil || carry > 0 {
        sum := carry
        
        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }
        
        // Вычисляем новую цифру и перенос
        digit := sum % 10
        carry = sum / 10
        
        // Создаем новый узел
        current.Next = &ListNode{Val: digit}
        current = current.Next
    }
    
    return dummy.Next
}
```

**Анализ**:
- **Временная сложность**: O(max(n, m)) - где n и m - длины списков
- **Пространственная сложность**: O(max(n, m)) - для хранения результата

**Ключевые моменты**:
- Обработка переноса при сложении
- Продолжение обхода, пока есть узлы в любом из списков или перенос
- Использование фиктивного узла для упрощения обработки

### 2. Longest Substring Without Repeating Characters (Наибольшая подстрока без повторяющихся символов)

**Задача**: Дана строка `s`. Найдите длину наибольшей подстроки без повторяющихся символов.

**Пример**:
```
Input: s = "abcabcbb"
Output: 3
Explanation: Наибольшая подстрока без повторяющихся символов - "abc", длина 3.
```

**Решение** (скользящее окно):
```go
func lengthOfLongestSubstring(s string) int {
    // Карта для хранения последней позиции каждого символа
    charMap := make(map[byte]int)
    maxLength := 0
    start := 0
    
    for i := 0; i < len(s); i++ {
        // Если символ уже встречался в текущем окне, обновляем начало окна
        if pos, found := charMap[s[i]]; found && pos >= start {
            start = pos + 1
        }
        
        // Обновляем позицию символа
        charMap[s[i]] = i
        
        // Вычисляем длину текущего окна
        currentLength := i - start + 1
        
        // Обновляем максимальную длину
        if currentLength > maxLength {
            maxLength = currentLength
        }
    }
    
    return maxLength
}
```

**Анализ**:
- **Временная сложность**: O(n) - один проход по строке
- **Пространственная сложность**: O(min(m, n)) - где m - размер алфавита

**Ключевые моменты**:
- Использование техники скользящего окна
- Отслеживание последней позиции каждого символа
- Обновление начала окна при обнаружении повторяющегося символа

### 3. 3Sum (Три числа)

**Задача**: Дан массив целых чисел `nums`. Верните все тройки [nums[i], nums[j], nums[k]], такие что i != j, i != k, j != k, и nums[i] + nums[j] + nums[k] = 0.

**Пример**:
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Решение**:
```go
func threeSum(nums []int) [][]int {
    result := [][]int{}
    
    // Сортируем массив
    sort.Ints(nums)
    
    for i := 0; i < len(nums)-2; i++ {
        // Пропускаем дубликаты
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        
        // Используем подход с двумя указателями
        left := i + 1
        right := len(nums) - 1
        
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            
            if sum < 0 {
                left++
            } else if sum > 0 {
                right--
            } else {
                // Нашли тройку
                result = append(result, []int{nums[i], nums[left], nums[right]})
                
                // Пропускаем дубликаты
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                
                left++
                right--
            }
        }
    }
    
    return result
}
```

**Анализ**:
- **Временная сложность**: O(n²) - сортировка O(n log n) + вложенные циклы O(n²)
- **Пространственная сложность**: O(1) - не считая результат

**Ключевые моменты**:
- Сортировка массива для упрощения поиска
- Использование техники двух указателей для поиска пар
- Обработка дубликатов для избежания повторяющихся троек

### 4. Container With Most Water (Контейнер с наибольшим количеством воды)

**Задача**: Дан массив целых чисел `height` длины n. Есть n вертикальных линий, где i-я линия имеет высоту height[i]. Найдите две линии, которые вместе с осью x образуют контейнер, содержащий наибольшее количество воды.

**Пример**:
```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: Контейнер образуют линии на позициях 1 и 8 (высоты 8 и 7), площадь = min(8, 7) * (8 - 1) = 7 * 7 = 49.
```

**Решение** (два указателя):
```go
func maxArea(height []int) int {
    maxWater := 0
    left := 0
    right := len(height) - 1
    
    for left < right {
        // Вычисляем ширину и высоту контейнера
        width := right - left
        h := min(height[left], height[right])
        
        // Вычисляем объем воды
        water := width * h
        
        // Обновляем максимум
        if water > maxWater {
            maxWater = water
        }
        
        // Перемещаем указатели
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    
    return maxWater
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**Анализ**:
- **Временная сложность**: O(n) - один проход по массиву
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Использование техники двух указателей
- Перемещение указателя с меньшей высотой для потенциального увеличения объема
- Вычисление объема как произведение ширины на минимальную высоту

### 5. Coin Change (Размен монет)

**Задача**: Дан массив монет разного номинала `coins` и сумма `amount`. Верните минимальное количество монет, необходимое для размена суммы. Если размен невозможен, верните -1.

**Пример**:
```
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
```

**Решение** (динамическое программирование):
```go
func coinChange(coins []int, amount int) int {
    // Инициализируем массив для хранения минимального количества монет
    dp := make([]int, amount+1)
    
    // Заполняем массив значением, большим максимально возможного количества монет
    for i := range dp {
        dp[i] = amount + 1
    }
    
    // Базовый случай: для размена 0 нужно 0 монет
    dp[0] = 0
    
    // Заполняем массив
    for _, coin := range coins {
        for i := coin; i <= amount; i++ {
            dp[i] = min(dp[i], dp[i-coin]+1)
        }
    }
    
    // Если значение не изменилось, размен невозможен
    if dp[amount] > amount {
        return -1
    }
    
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**Анализ**:
- **Временная сложность**: O(amount * n) - где n - количество монет
- **Пространственная сложность**: O(amount)

**Ключевые моменты**:
- Использование динамического программирования
- Рекуррентное соотношение: dp[i] = min(dp[i], dp[i-coin]+1)
- Инициализация массива значением, большим максимально возможного количества монет
- Проверка возможности размена

## Задачи на деревья и графы

### 1. Binary Tree Inorder Traversal (Обход бинарного дерева в порядке in-order)

**Задача**: Дан корень бинарного дерева. Верните элементы дерева при обходе в порядке in-order (левый -> корень -> правый).

**Пример**:
```
Input: root = [1,null,2,3]
Output: [1,3,2]
```

**Решение** (рекурсивное):
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) []int {
    result := []int{}
    inorder(root, &result)
    return result
}

func inorder(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    
    inorder(node.Left, result)
    *result = append(*result, node.Val)
    inorder(node.Right, result)
}
```

**Решение** (итеративное):
```go
func inorderTraversal(root *TreeNode) []int {
    result := []int{}
    stack := []*TreeNode{}
    current := root
    
    for current != nil || len(stack) > 0 {
        // Идем влево до конца
        for current != nil {
            stack = append(stack, current)
            current = current.Left
        }
        
        // Извлекаем узел из стека
        current = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        
        // Добавляем значение в результат
        result = append(result, current.Val)
        
        // Переходим к правому поддереву
        current = current.Right
    }
    
    return result
}
```

**Анализ**:
- **Временная сложность**: O(n) - посещаем каждый узел один раз
- **Пространственная сложность**: O(h) - где h - высота дерева

**Ключевые моменты**:
- Рекурсивный обход следует порядку: левый -> корень -> правый
- Итеративное решение использует стек для имитации рекурсии
- Обработка пустого дерева

### 2. Validate Binary Search Tree (Проверка бинарного дерева поиска)

**Задача**: Дан корень бинарного дерева. Определите, является ли оно бинарным деревом поиска (BST).

**Пример**:
```
Input: root = [2,1,3]
Output: true

Input: root = [5,1,4,null,null,3,6]
Output: false
```

**Решение**:
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isValidBST(root *TreeNode) bool {
    return validate(root, nil, nil)
}

func validate(node *TreeNode, min, max *int) bool {
    if node == nil {
        return true
    }
    
    // Проверяем, что значение узла находится в допустимом диапазоне
    if (min != nil && node.Val <= *min) || (max != nil && node.Val >= *max) {
        return false
    }
    
    // Рекурсивно проверяем левое и правое поддеревья
    return validate(node.Left, min, &node.Val) && validate(node.Right, &node.Val, max)
}
```

**Анализ**:
- **Временная сложность**: O(n) - посещаем каждый узел один раз
- **Пространственная сложность**: O(h) - где h - высота дерева

**Ключевые моменты**:
- Проверка, что каждый узел находится в допустимом диапазоне значений
- Обновление диапазона при рекурсивном обходе
- Использование указателей для обработки граничных случаев

### 3. Number of Islands (Количество островов)

**Задача**: Дана двумерная сетка, заполненная '1' (земля) и '0' (вода). Остров - это группа соседних (по горизонтали или вертикали) ячеек '1'. Подсчитайте количество островов.

**Пример**:
```
Input:
[
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

**Решение** (DFS):
```go
func numIslands(grid [][]byte) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }
    
    count := 0
    rows, cols := len(grid), len(grid[0])
    
    // Функция для обхода острова
    var dfs func(r, c int)
    dfs = func(r, c int) {
        // Проверяем границы и наличие земли
        if r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] != '1' {
            return
        }
        
        // Помечаем ячейку как посещенную
        grid[r][c] = '0'
        
        // Рекурсивно обходим соседние ячейки
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    }
    
    // Обходим всю сетку
    for r := 0; r < rows; r++ {
        for c := 0; c < cols; c++ {
            if grid[r][c] == '1' {
                count++
                dfs(r, c)
            }
        }
    }
    
    return count
}
```

**Анализ**:
- **Временная сложность**: O(m * n) - где m и n - размеры сетки
- **Пространственная сложность**: O(m * n) - в худшем случае для рекурсии

**Ключевые моменты**:
- Использование DFS для обхода островов
- Пометка посещенных ячеек для избежания повторного обхода
- Инкремент счетчика при обнаружении нового острова

### 4. Course Schedule (Расписание курсов)

**Задача**: Есть n курсов, пронумерованных от 0 до n-1. Некоторые курсы имеют предварительные требования: например, чтобы пройти курс 0, нужно сначала пройти курс 1, что выражается как пара [0,1]. Определите, можно ли пройти все курсы.

**Пример**:
```
Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: Есть 2 курса. Чтобы пройти курс 1, нужно сначала пройти курс 0. Это возможно.
```

**Решение** (обнаружение цикла в графе):
```go
func canFinish(numCourses int, prerequisites [][]int) bool {
    // Создаем список смежности
    graph := make([][]int, numCourses)
    for _, prereq := range prerequisites {
        course, prerequisite := prereq[0], prereq[1]
        graph[course] = append(graph[course], prerequisite)
    }
    
    // Массивы для отслеживания посещенных вершин и вершин в текущем пути
    visited := make([]bool, numCourses)
    inPath := make([]bool, numCourses)
    
    // Функция для обнаружения цикла
    var hasCycle func(course int) bool
    hasCycle = func(course int) bool {
        // Если вершина уже в текущем пути, найден цикл
        if inPath[course] {
            return true
        }
        
        // Если вершина уже посещена и не в текущем пути, нет цикла
        if visited[course] {
            return false
        }
        
        // Помечаем вершину как посещенную и добавляем в текущий путь
        visited[course] = true
        inPath[course] = true
        
        // Проверяем все предварительные требования
        for _, prereq := range graph[course] {
            if hasCycle(prereq) {
                return true
            }
        }
        
        // Удаляем вершину из текущего пути
        inPath[course] = false
        
        return false
    }
    
    // Проверяем каждый курс
    for course := 0; course < numCourses; course++ {
        if !visited[course] && hasCycle(course) {
            return false
        }
    }
    
    return true
}
```

**Анализ**:
- **Временная сложность**: O(V + E) - где V - количество вершин, E - количество ребер
- **Пространственная сложность**: O(V + E)

**Ключевые моменты**:
- Представление предварительных требований как ориентированного графа
- Обнаружение цикла в графе с помощью DFS
- Использование двух массивов для отслеживания посещенных вершин и вершин в текущем пути

## Задачи на динамическое программирование

### 1. Longest Increasing Subsequence (Наибольшая возрастающая подпоследовательность)

**Задача**: Дан целочисленный массив `nums`. Найдите длину наибольшей строго возрастающей подпоследовательности.

**Пример**:
```
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: Наибольшая возрастающая подпоследовательность - [2,3,7,101], длина 4.
```

**Решение** (динамическое программирование):
```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    // Инициализируем массив dp
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1 // Минимальная длина подпоследовательности - 1
    }
    
    maxLength := 1
    
    // Заполняем массив dp
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        
        maxLength = max(maxLength, dp[i])
    }
    
    return maxLength
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**Оптимизированное решение** (бинарный поиск):
```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    // Массив для хранения потенциальной НВП
    tails := make([]int, len(nums))
    size := 0
    
    for _, num := range nums {
        // Бинарный поиск позиции для вставки
        left, right := 0, size
        for left < right {
            mid := left + (right-left)/2
            if tails[mid] < num {
                left = mid + 1
            } else {
                right = mid
            }
        }
        
        // Обновляем tails и size
        tails[left] = num
        if left == size {
            size++
        }
    }
    
    return size
}
```

**Анализ**:
- **Временная сложность**: O(n²) для DP-решения, O(n log n) для оптимизированного решения
- **Пространственная сложность**: O(n)

**Ключевые моменты**:
- Динамическое программирование: dp[i] - длина НВП, заканчивающейся на i-м элементе
- Оптимизация с использованием бинарного поиска
- Массив tails хранит наименьшие конечные элементы для НВП разной длины

### 2. Unique Paths (Уникальные пути)

**Задача**: Робот находится в верхнем левом углу сетки размером m x n. Робот может двигаться только вниз или вправо. Сколько уникальных путей существует до правого нижнего угла?

**Пример**:
```
Input: m = 3, n = 7
Output: 28
```

**Решение** (динамическое программирование):
```go
func uniquePaths(m int, n int) int {
    // Инициализируем двумерный массив dp
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    
    // Заполняем первую строку и первый столбец единицами
    for i := 0; i < m; i++ {
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }
    
    // Заполняем остальные ячейки
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    
    return dp[m-1][n-1]
}
```

**Оптимизированное решение** (одномерный массив):
```go
func uniquePaths(m int, n int) int {
    // Используем одномерный массив
    dp := make([]int, n)
    
    // Инициализируем массив единицами
    for i := 0; i < n; i++ {
        dp[i] = 1
    }
    
    // Обновляем массив
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[j] += dp[j-1]
        }
    }
    
    return dp[n-1]
}
```

**Анализ**:
- **Временная сложность**: O(m * n)
- **Пространственная сложность**: O(n) для оптимизированного решения

**Ключевые моменты**:
- Рекуррентное соотношение: dp[i][j] = dp[i-1][j] + dp[i][j-1]
- Оптимизация пространственной сложности с использованием одномерного массива
- Инициализация граничных условий

### 3. Word Break (Разбиение слова)

**Задача**: Дана строка `s` и словарь `wordDict`. Определите, можно ли разбить строку на последовательность слов из словаря.

**Пример**:
```
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Строку можно разбить как "leet code".
```

**Решение** (динамическое программирование):
```go
func wordBreak(s string, wordDict []string) bool {
    // Создаем множество слов для быстрого поиска
    wordSet := make(map[string]bool)
    for _, word := range wordDict {
        wordSet[word] = true
    }
    
    // Инициализируем массив dp
    dp := make([]bool, len(s)+1)
    dp[0] = true // Пустая строка всегда может быть разбита
    
    // Заполняем массив dp
    for i := 1; i <= len(s); i++ {
        for j := 0; j < i; j++ {
            if dp[j] && wordSet[s[j:i]] {
                dp[i] = true
                break
            }
        }
    }
    
    return dp[len(s)]
}
```

**Анализ**:
- **Временная сложность**: O(n²) - где n - длина строки
- **Пространственная сложность**: O(n)

**Ключевые моменты**:
- dp[i] означает, можно ли разбить подстроку s[0:i]
- Проверяем все возможные разбиения на каждом шаге
- Используем множество для быстрого поиска слов в словаре

## Заключение

В этом руководстве мы рассмотрели типичные задачи с LeetCode, которые часто встречаются на технических интервью. Для каждой задачи было представлено подробное решение на Go с объяснением подхода и анализом сложности.

Ключевые моменты для успешного решения задач на интервью:
1. Понимание задачи и уточнение требований
2. Разработка подхода и обсуждение различных решений
3. Анализ временной и пространственной сложности
4. Чистая и понятная реализация
5. Тестирование решения на примерах и граничных случаях

Регулярная практика на LeetCode поможет вам развить навыки решения алгоритмических задач и уверенно пройти техническое интервью в компаниях уровня Яндекс и Озон.
