# Практические задачи по алгоритмам для подготовки к интервью

В этом документе представлены практические задачи по алгоритмам и структурам данных, которые помогут вам подготовиться к техническому интервью в Яндексе и Озоне. Задачи разделены по категориям и включают решения с пояснениями.

## Массивы и строки

### Задача 1: Поиск пропущенного числа

**Задание**: Дан массив чисел от 1 до n, в котором пропущено одно число. Найдите пропущенное число.

**Пример**:
```
Input: [1, 2, 4, 5, 6]
Output: 3
```

**Решение 1** (математический подход):
```go
func missingNumber(nums []int) int {
    n := len(nums) + 1
    expectedSum := n * (n + 1) / 2
    actualSum := 0
    
    for _, num := range nums {
        actualSum += num
    }
    
    return expectedSum - actualSum
}
```

**Решение 2** (с использованием XOR):
```go
func missingNumber(nums []int) int {
    n := len(nums) + 1
    result := 0
    
    // XOR всех чисел от 1 до n
    for i := 1; i <= n; i++ {
        result ^= i
    }
    
    // XOR всех чисел в массиве
    for _, num := range nums {
        result ^= num
    }
    
    return result
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Математический подход использует формулу суммы арифметической прогрессии
- Подход с XOR основан на свойстве: a ^ a = 0 и a ^ 0 = a

### Задача 2: Поиск дубликатов в массиве

**Задание**: Дан массив целых чисел, в котором каждое число встречается дважды, кроме одного. Найдите это число.

**Пример**:
```
Input: [4, 1, 2, 1, 2]
Output: 4
```

**Решение** (с использованием XOR):
```go
func singleNumber(nums []int) int {
    result := 0
    
    for _, num := range nums {
        result ^= num
    }
    
    return result
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- XOR одинаковых чисел дает 0
- XOR числа с 0 дает само число
- Последовательное применение XOR ко всем элементам оставит только уникальное число

### Задача 3: Поворот матрицы

**Задание**: Дана квадратная матрица размером n x n. Поверните ее на 90 градусов по часовой стрелке.

**Пример**:
```
Input:
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
Output:
[
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3]
]
```

**Решение**:
```go
func rotate(matrix [][]int) {
    n := len(matrix)
    
    // Транспонирование матрицы
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
    
    // Отражение по вертикали
    for i := 0; i < n; i++ {
        for j := 0; j < n/2; j++ {
            matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]
        }
    }
}
```

**Анализ**:
- **Временная сложность**: O(n²)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Поворот на 90° = транспонирование + отражение по вертикали
- Транспонирование: элемент [i][j] меняется местами с [j][i]
- Отражение по вертикали: элемент [i][j] меняется местами с [i][n-j-1]

### Задача 4: Проверка анаграммы

**Задание**: Даны две строки. Определите, являются ли они анаграммами (содержат одинаковые символы в разном порядке).

**Пример**:
```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Решение**:
```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
        return false
    }
    
    // Создаем карту для подсчета символов
    charCount := make(map[rune]int)
    
    // Увеличиваем счетчики для символов первой строки
    for _, char := range s {
        charCount[char]++
    }
    
    // Уменьшаем счетчики для символов второй строки
    for _, char := range t {
        charCount[char]--
        if charCount[char] < 0 {
            return false
        }
    }
    
    // Проверяем, что все счетчики равны нулю
    for _, count := range charCount {
        if count != 0 {
            return false
        }
    }
    
    return true
}
```

**Оптимизированное решение** (для ASCII-символов):
```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
        return false
    }
    
    // Массив для подсчета символов (для ASCII)
    counts := [26]int{}
    
    // Увеличиваем счетчики для символов первой строки
    for i := 0; i < len(s); i++ {
        counts[s[i]-'a']++
    }
    
    // Уменьшаем счетчики для символов второй строки
    for i := 0; i < len(t); i++ {
        counts[t[i]-'a']--
        if counts[t[i]-'a'] < 0 {
            return false
        }
    }
    
    return true
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1) для оптимизированного решения (фиксированный размер массива)

**Ключевые моменты**:
- Анаграммы имеют одинаковую длину и одинаковое количество каждого символа
- Можно использовать карту или массив для подсчета символов
- Для ASCII-символов массив фиксированного размера эффективнее

## Связные списки

### Задача 1: Обнаружение цикла в связном списке

**Задание**: Дан связный список. Определите, содержит ли он цикл.

**Пример**:
```
Input: head = [3,2,0,-4], pos = 1 (указывает на позицию, где хвост соединяется с узлом)
Output: true
```

**Решение** (алгоритм "черепаха и заяц"):
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false
    }
    
    slow := head
    fast := head.Next
    
    for slow != fast {
        if fast == nil || fast.Next == nil {
            return false
        }
        slow = slow.Next
        fast = fast.Next.Next
    }
    
    return true
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Алгоритм "черепаха и заяц" использует два указателя, движущихся с разной скоростью
- Если есть цикл, быстрый указатель догонит медленный
- Если нет цикла, быстрый указатель достигнет конца списка

### Задача 2: Удаление n-го узла с конца списка

**Задание**: Дан связный список. Удалите n-й узел с конца списка и верните голову списка.

**Пример**:
```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Решение**:
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    // Создаем фиктивный узел для упрощения обработки
    dummy := &ListNode{Next: head}
    
    // Инициализируем два указателя
    first := dummy
    second := dummy
    
    // Перемещаем первый указатель на n+1 узлов вперед
    for i := 0; i <= n; i++ {
        first = first.Next
    }
    
    // Перемещаем оба указателя до конца списка
    for first != nil {
        first = first.Next
        second = second.Next
    }
    
    // Удаляем n-й узел с конца
    second.Next = second.Next.Next
    
    return dummy.Next
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Использование двух указателей с расстоянием n между ними
- Фиктивный узел упрощает обработку граничных случаев
- Когда первый указатель достигает конца, второй указывает на узел перед удаляемым

### Задача 3: Разворот связного списка

**Задание**: Дан связный список. Разверните его и верните новую голову.

**Пример**:
```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Решение**:
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    current := head
    
    for current != nil {
        // Сохраняем следующий узел
        next := current.Next
        
        // Меняем указатель на следующий узел
        current.Next = prev
        
        // Перемещаем указатели
        prev = current
        current = next
    }
    
    return prev
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Итеративный подход с использованием трех указателей
- Последовательное изменение направления указателей
- Новая голова списка - последний узел исходного списка

## Деревья и графы

### Задача 1: Максимальная глубина бинарного дерева

**Задание**: Дано бинарное дерево. Найдите его максимальную глубину (количество узлов на самом длинном пути от корня до листа).

**Пример**:
```
Input: root = [3,9,20,null,null,15,7]
Output: 3
```

**Решение** (рекурсивное):
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    
    return max(leftDepth, rightDepth) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**Решение** (итеративное с BFS):
```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    
    queue := []*TreeNode{root}
    depth := 0
    
    for len(queue) > 0 {
        size := len(queue)
        
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        
        depth++
    }
    
    return depth
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(h) для рекурсивного решения, O(w) для итеративного (h - высота дерева, w - максимальная ширина)

**Ключевые моменты**:
- Рекурсивное решение использует формулу: глубина = max(глубина левого поддерева, глубина правого поддерева) + 1
- Итеративное решение использует BFS для обхода дерева по уровням
- Оба подхода посещают каждый узел ровно один раз

### Задача 2: Проверка симметричности бинарного дерева

**Задание**: Дано бинарное дерево. Проверьте, является ли оно симметричным (зеркальным относительно центра).

**Пример**:
```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

**Решение** (рекурсивное):
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    
    return isMirror(root.Left, root.Right)
}

func isMirror(left, right *TreeNode) bool {
    // Оба поддерева пусты
    if left == nil && right == nil {
        return true
    }
    
    // Только одно поддерево пусто
    if left == nil || right == nil {
        return false
    }
    
    // Значения корней должны совпадать
    // Левое поддерево левого должно быть зеркальным отражением правого поддерева правого
    // Правое поддерево левого должно быть зеркальным отражением левого поддерева правого
    return left.Val == right.Val &&
           isMirror(left.Left, right.Right) &&
           isMirror(left.Right, right.Left)
}
```

**Решение** (итеративное):
```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    
    queue := []*TreeNode{root.Left, root.Right}
    
    for len(queue) > 0 {
        left := queue[0]
        right := queue[1]
        queue = queue[2:]
        
        if left == nil && right == nil {
            continue
        }
        
        if left == nil || right == nil || left.Val != right.Val {
            return false
        }
        
        queue = append(queue, left.Left, right.Right, left.Right, right.Left)
    }
    
    return true
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(h) для рекурсивного решения, O(w) для итеративного

**Ключевые моменты**:
- Дерево симметрично, если его левое поддерево является зеркальным отражением правого
- Рекурсивное решение проверяет симметричность пар узлов
- Итеративное решение использует очередь для хранения пар узлов

### Задача 3: Поиск кратчайшего пути в графе (BFS)

**Задание**: Дан неориентированный граф, представленный списком смежности. Найдите кратчайший путь от вершины start до вершины end.

**Пример**:
```
Input: graph = [[1,2],[0,2,3],[0,1],[1]], start = 0, end = 3
Output: 2 (путь: 0 -> 1 -> 3)
```

**Решение**:
```go
func shortestPath(graph [][]int, start, end int) int {
    if start == end {
        return 0
    }
    
    // Очередь для BFS
    queue := []int{start}
    
    // Массив для отслеживания посещенных вершин
    visited := make([]bool, len(graph))
    visited[start] = true
    
    // Массив для отслеживания расстояний
    distance := make([]int, len(graph))
    
    for len(queue) > 0 {
        // Извлекаем вершину из очереди
        vertex := queue[0]
        queue = queue[1:]
        
        // Обрабатываем соседей
        for _, neighbor := range graph[vertex] {
            if !visited[neighbor] {
                visited[neighbor] = true
                distance[neighbor] = distance[vertex] + 1
                
                if neighbor == end {
                    return distance[neighbor]
                }
                
                queue = append(queue, neighbor)
            }
        }
    }
    
    return -1 // Путь не найден
}
```

**Анализ**:
- **Временная сложность**: O(V + E) - где V - количество вершин, E - количество ребер
- **Пространственная сложность**: O(V)

**Ключевые моменты**:
- BFS гарантирует нахождение кратчайшего пути в невзвешенном графе
- Используем очередь для обхода вершин по уровням
- Отслеживаем посещенные вершины и расстояния

### Задача 4: Топологическая сортировка (DFS)

**Задание**: Дан ориентированный ациклический граф (DAG), представленный списком смежности. Выполните топологическую сортировку вершин.

**Пример**:
```
Input: graph = [[1,2],[3],[3],[]]
Output: [0,1,2,3] или [0,2,1,3]
```

**Решение**:
```go
func topologicalSort(graph [][]int) []int {
    n := len(graph)
    visited := make([]bool, n)
    temp := make([]bool, n) // Для обнаружения циклов
    result := []int{}
    
    var dfs func(node int) bool
    dfs = func(node int) bool {
        // Если вершина уже в текущем пути, найден цикл
        if temp[node] {
            return false
        }
        
        // Если вершина уже посещена, пропускаем
        if visited[node] {
            return true
        }
        
        // Помечаем вершину как часть текущего пути
        temp[node] = true
        
        // Рекурсивно обходим соседей
        for _, neighbor := range graph[node] {
            if !dfs(neighbor) {
                return false
            }
        }
        
        // Помечаем вершину как посещенную
        visited[node] = true
        temp[node] = false
        
        // Добавляем вершину в результат
        result = append(result, node)
        
        return true
    }
    
    // Обходим все вершины
    for i := 0; i < n; i++ {
        if !visited[i] {
            if !dfs(i) {
                return nil // Граф содержит цикл
            }
        }
    }
    
    // Переворачиваем результат
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
        result[i], result[j] = result[j], result[i]
    }
    
    return result
}
```

**Анализ**:
- **Временная сложность**: O(V + E)
- **Пространственная сложность**: O(V)

**Ключевые моменты**:
- Топологическая сортировка определяет порядок вершин, при котором для каждого ребра u -> v вершина u идет перед v
- Используем DFS для обхода графа
- Добавляем вершину в результат после обхода всех ее соседей
- Результат нужно перевернуть, чтобы получить правильный порядок

## Динамическое программирование

### Задача 1: Лестница (Climbing Stairs)

**Задание**: Вы поднимаетесь по лестнице. Требуется n шагов, чтобы достичь вершины. Каждый раз вы можете подняться на 1 или 2 ступеньки. Сколькими различными способами вы можете подняться на вершину?

**Пример**:
```
Input: n = 3
Output: 3
Explanation: Есть три способа подняться на вершину:
1. 1 шаг + 1 шаг + 1 шаг
2. 1 шаг + 2 шага
3. 2 шага + 1 шаг
```

**Решение**:
```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    
    // Инициализируем первые два значения
    prev1 := 1 // f(1) = 1
    prev2 := 2 // f(2) = 2
    
    // Вычисляем f(n) = f(n-1) + f(n-2)
    for i := 3; i <= n; i++ {
        current := prev1 + prev2
        prev1 = prev2
        prev2 = current
    }
    
    return prev2
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Классическая задача на динамическое программирование
- Рекуррентное соотношение: f(n) = f(n-1) + f(n-2)
- Оптимизация пространственной сложности с использованием только двух переменных

### Задача 2: Максимальная сумма подмассива (Kadane's Algorithm)

**Задание**: Дан целочисленный массив nums. Найдите подмассив с наибольшей суммой и верните эту сумму.

**Пример**:
```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: Подмассив [4,-1,2,1] имеет наибольшую сумму 6.
```

**Решение**:
```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    maxSoFar := nums[0]
    maxEndingHere := nums[0]
    
    for i := 1; i < len(nums); i++ {
        // Выбираем лучшее: начать новый подмассив или продолжить текущий
        maxEndingHere = max(nums[i], maxEndingHere+nums[i])
        
        // Обновляем глобальный максимум
        maxSoFar = max(maxSoFar, maxEndingHere)
    }
    
    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Алгоритм Кадане для нахождения максимального подмассива
- На каждом шаге решаем: начать новый подмассив или продолжить текущий
- Отслеживаем глобальный максимум на протяжении всего алгоритма

### Задача 3: Наибольшая общая подпоследовательность (LCS)

**Задание**: Даны две строки text1 и text2. Верните длину их наибольшей общей подпоследовательности. Если общей подпоследовательности нет, верните 0.

**Пример**:
```
Input: text1 = "abcde", text2 = "ace"
Output: 3
Explanation: Наибольшая общая подпоследовательность - "ace", длина 3.
```

**Решение**:
```go
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    
    // Инициализируем двумерный массив dp
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    // Заполняем массив dp
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**Оптимизированное решение** (с использованием одномерного массива):
```go
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    
    // Для оптимизации памяти используем строку меньшей длины для внешнего цикла
    if m < n {
        text1, text2 = text2, text1
        m, n = n, m
    }
    
    // Инициализируем одномерный массив dp
    dp := make([]int, n+1)
    
    for i := 1; i <= m; i++ {
        prev := 0 // dp[i-1][j-1]
        
        for j := 1; j <= n; j++ {
            temp := dp[j] // Сохраняем dp[i-1][j]
            
            if text1[i-1] == text2[j-1] {
                dp[j] = prev + 1
            } else {
                dp[j] = max(dp[j], dp[j-1])
            }
            
            prev = temp
        }
    }
    
    return dp[n]
}
```

**Анализ**:
- **Временная сложность**: O(m * n)
- **Пространственная сложность**: O(min(m, n)) для оптимизированного решения

**Ключевые моменты**:
- Классическая задача на динамическое программирование
- Рекуррентное соотношение:
  - Если символы совпадают: dp[i][j] = dp[i-1][j-1] + 1
  - Иначе: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
- Оптимизация пространственной сложности с использованием одномерного массива

### Задача 4: Задача о рюкзаке (0/1 Knapsack)

**Задание**: Дан набор предметов, каждый с весом и стоимостью. Определите максимальную стоимость, которую можно получить, выбрав предметы с общим весом, не превышающим заданную вместимость рюкзака.

**Пример**:
```
Input: values = [60, 100, 120], weights = [10, 20, 30], capacity = 50
Output: 220
Explanation: Выбираем предметы с весами 20 и 30, получая стоимость 100 + 120 = 220.
```

**Решение**:
```go
func knapsack(values []int, weights []int, capacity int) int {
    n := len(values)
    
    // Инициализируем двумерный массив dp
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    
    // Заполняем массив dp
    for i := 1; i <= n; i++ {
        for w := 0; w <= capacity; w++ {
            // Не берем i-й предмет
            dp[i][w] = dp[i-1][w]
            
            // Берем i-й предмет, если его вес не превышает текущую вместимость
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i][w], dp[i-1][w-weights[i-1]]+values[i-1])
            }
        }
    }
    
    return dp[n][capacity]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**Оптимизированное решение** (с использованием одномерного массива):
```go
func knapsack(values []int, weights []int, capacity int) int {
    n := len(values)
    
    // Инициализируем одномерный массив dp
    dp := make([]int, capacity+1)
    
    // Заполняем массив dp
    for i := 0; i < n; i++ {
        // Важно: обрабатываем в обратном порядке, чтобы избежать повторного использования предмета
        for w := capacity; w >= weights[i]; w-- {
            dp[w] = max(dp[w], dp[w-weights[i]]+values[i])
        }
    }
    
    return dp[capacity]
}
```

**Анализ**:
- **Временная сложность**: O(n * capacity)
- **Пространственная сложность**: O(capacity) для оптимизированного решения

**Ключевые моменты**:
- Классическая задача на динамическое программирование
- Рекуррентное соотношение: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
- Оптимизация пространственной сложности с использованием одномерного массива
- При использовании одномерного массива важно обрабатывать веса в обратном порядке

## Задачи на поиск и сортировку

### Задача 1: Поиск в отсортированном массиве с поворотом

**Задание**: Дан отсортированный массив, который был повернут на неизвестное количество позиций. Найдите в нем заданное число. Предполагается, что в массиве нет дубликатов.

**Пример**:
```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Решение**:
```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if nums[mid] == target {
            return mid
        }
        
        // Определяем, в какой части находится средний элемент
        if nums[left] <= nums[mid] {
            // Левая часть отсортирована
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            // Правая часть отсортирована
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    
    return -1
}
```

**Анализ**:
- **Временная сложность**: O(log n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Модифицированный бинарный поиск
- На каждом шаге определяем, какая часть массива отсортирована
- Проверяем, находится ли целевое число в отсортированной части

### Задача 2: Поиск медианы двух отсортированных массивов

**Задание**: Даны два отсортированных массива nums1 и nums2 размеров m и n соответственно. Найдите медиану объединенного массива.

**Пример**:
```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.0

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.5
```

**Решение**:
```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    // Обеспечиваем, что nums1 - более короткий массив
    if len(nums1) > len(nums2) {
        nums1, nums2 = nums2, nums1
    }
    
    x, y := len(nums1), len(nums2)
    low, high := 0, x
    
    for low <= high {
        partitionX := (low + high) / 2
        partitionY := (x + y + 1) / 2 - partitionX
        
        // Если partitionX равен 0, то maxX = -∞
        // Если partitionX равен x, то minX = +∞
        maxX := math.MinInt32
        if partitionX > 0 {
            maxX = nums1[partitionX-1]
        }
        
        minX := math.MaxInt32
        if partitionX < x {
            minX = nums1[partitionX]
        }
        
        // Если partitionY равен 0, то maxY = -∞
        // Если partitionY равен y, то minY = +∞
        maxY := math.MinInt32
        if partitionY > 0 {
            maxY = nums2[partitionY-1]
        }
        
        minY := math.MaxInt32
        if partitionY < y {
            minY = nums2[partitionY]
        }
        
        if maxX <= minY && maxY <= minX {
            // Нашли правильное разделение
            if (x+y)%2 == 0 {
                return float64(max(maxX, maxY)+min(minX, minY)) / 2.0
            } else {
                return float64(max(maxX, maxY))
            }
        } else if maxX > minY {
            // Слишком много элементов в X, уменьшаем partitionX
            high = partitionX - 1
        } else {
            // Слишком мало элементов в X, увеличиваем partitionX
            low = partitionX + 1
        }
    }
    
    return 0.0
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**Анализ**:
- **Временная сложность**: O(log(min(m, n)))
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Бинарный поиск по более короткому массиву
- Разделение массивов на две части так, чтобы левая часть содержала (m+n+1)/2 элементов
- Проверка условий: maxX <= minY и maxY <= minX
- Обработка четного и нечетного количества элементов

### Задача 3: Быстрая сортировка (Quick Sort)

**Задание**: Реализуйте алгоритм быстрой сортировки для массива целых чисел.

**Решение**:
```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    // Выбираем опорный элемент
    pivot := arr[len(arr)/2]
    
    // Разделяем массив на три части
    var less, equal, greater []int
    
    for _, num := range arr {
        if num < pivot {
            less = append(less, num)
        } else if num == pivot {
            equal = append(equal, num)
        } else {
            greater = append(greater, num)
        }
    }
    
    // Рекурсивно сортируем подмассивы и объединяем результаты
    less = quickSort(less)
    greater = quickSort(greater)
    
    return append(append(less, equal...), greater...)
}
```

**Оптимизированное решение** (сортировка на месте):
```go
func quickSort(arr []int, low, high int) {
    if low < high {
        // Разделение массива и получение индекса опорного элемента
        pivotIndex := partition(arr, low, high)
        
        // Рекурсивная сортировка подмассивов
        quickSort(arr, low, pivotIndex-1)
        quickSort(arr, pivotIndex+1, high)
    }
}

func partition(arr []int, low, high int) int {
    // Выбираем опорный элемент (последний элемент)
    pivot := arr[high]
    
    // Индекс меньшего элемента
    i := low - 1
    
    for j := low; j < high; j++ {
        // Если текущий элемент меньше или равен опорному
        if arr[j] <= pivot {
            i++
            // Меняем местами arr[i] и arr[j]
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    
    // Меняем местами arr[i+1] и arr[high] (опорный элемент)
    arr[i+1], arr[high] = arr[high], arr[i+1]
    
    return i + 1
}

// Использование:
// arr := []int{10, 7, 8, 9, 1, 5}
// quickSort(arr, 0, len(arr)-1)
```

**Анализ**:
- **Временная сложность**: O(n log n) в среднем, O(n²) в худшем случае
- **Пространственная сложность**: O(log n) для рекурсии

**Ключевые моменты**:
- Выбор опорного элемента влияет на эффективность алгоритма
- Разделение массива на элементы меньше, равные и больше опорного
- Рекурсивная сортировка подмассивов
- Оптимизированная версия выполняет сортировку на месте

### Задача 4: Сортировка слиянием (Merge Sort)

**Задание**: Реализуйте алгоритм сортировки слиянием для массива целых чисел.

**Решение**:
```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    // Разделяем массив на две части
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    
    // Объединяем отсортированные части
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    
    // Сравниваем элементы из обоих массивов
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    
    // Добавляем оставшиеся элементы
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    
    return result
}
```

**Анализ**:
- **Временная сложность**: O(n log n)
- **Пространственная сложность**: O(n)

**Ключевые моменты**:
- Разделение массива на две части
- Рекурсивная сортировка каждой части
- Слияние отсортированных частей
- Стабильная сортировка (сохраняет относительный порядок равных элементов)

## Задачи на битовые операции

### Задача 1: Подсчет установленных битов

**Задание**: Дано целое число n. Подсчитайте количество установленных битов (битов, равных 1) в его двоичном представлении.

**Пример**:
```
Input: n = 11 (1011 в двоичной системе)
Output: 3
```

**Решение 1** (последовательное удаление младшего бита):
```go
func countBits(n int) int {
    count := 0
    
    for n > 0 {
        count += n & 1 // Проверяем младший бит
        n >>= 1       // Сдвигаем вправо на 1 бит
    }
    
    return count
}
```

**Решение 2** (Brian Kernighan's Algorithm):
```go
func countBits(n int) int {
    count := 0
    
    for n > 0 {
        n &= (n - 1) // Сбрасываем младший установленный бит
        count++
    }
    
    return count
}
```

**Анализ**:
- **Временная сложность**: O(log n) для первого решения, O(k) для второго (где k - количество установленных битов)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Первое решение проверяет каждый бит
- Второе решение (алгоритм Брайана Керниган) сбрасывает только установленные биты
- Операция n & (n - 1) сбрасывает младший установленный бит

### Задача 2: Проверка степени двойки

**Задание**: Дано целое число n. Определите, является ли оно степенью двойки.

**Пример**:
```
Input: n = 16
Output: true

Input: n = 15
Output: false
```

**Решение**:
```go
func isPowerOfTwo(n int) bool {
    if n <= 0 {
        return false
    }
    
    return (n & (n - 1)) == 0
}
```

**Анализ**:
- **Временная сложность**: O(1)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Степень двойки имеет только один установленный бит в двоичном представлении
- Операция n & (n - 1) сбрасывает младший установленный бит
- Если результат равен 0, то был только один установленный бит

### Задача 3: Нахождение одиночного числа

**Задание**: Дан массив целых чисел, в котором каждое число встречается трижды, кроме одного. Найдите это число.

**Пример**:
```
Input: nums = [2,2,3,2]
Output: 3
```

**Решение**:
```go
func singleNumber(nums []int) int {
    // Массив для подсчета битов
    bits := make([]int, 32)
    
    // Подсчитываем биты для каждого числа
    for _, num := range nums {
        for i := 0; i < 32; i++ {
            bits[i] += (num >> i) & 1
        }
    }
    
    // Собираем результат
    result := 0
    for i := 0; i < 32; i++ {
        if bits[i]%3 != 0 {
            result |= 1 << i
        }
    }
    
    return result
}
```

**Анализ**:
- **Временная сложность**: O(n)
- **Пространственная сложность**: O(1)

**Ключевые моменты**:
- Подсчитываем количество единиц в каждой битовой позиции
- Если число встречается трижды, то количество единиц в каждой позиции делится на 3
- Остаток от деления на 3 указывает на биты уникального числа

## Заключение

В этом документе мы рассмотрели практические задачи по алгоритмам и структурам данных, которые часто встречаются на технических интервью. Для каждой задачи было представлено решение с пояснениями и анализом сложности.

Ключевые моменты для успешного решения алгоритмических задач:
1. Понимание задачи и уточнение требований
2. Разработка подхода и обсуждение различных решений
3. Анализ временной и пространственной сложности
4. Чистая и понятная реализация
5. Тестирование решения на примерах и граничных случаях

Регулярная практика решения алгоритмических задач поможет вам развить навыки и уверенно пройти техническое интервью в компаниях уровня Яндекс и Озон.
