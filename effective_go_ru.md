# Эффективный Go
>
> Переведено [@region23](https://t.me/region23) при помощи `ChatGPT 4o` 05.03.2025

## Введение

Go — это новый язык. Хотя он заимствует идеи из существующих языков, у него есть уникальные свойства, которые делают эффективные программы на Go отличными по характеру от программ, написанных на его "родственниках". Прямой перевод программы на C++ или Java в Go вряд ли приведет к удовлетворительному результату — программы на Java пишутся на Java, а не на Go. С другой стороны, если рассмотреть проблему с точки зрения Go, можно создать успешную, но совершенно другую программу.

Другими словами, чтобы писать на Go хорошо, важно понимать его свойства и идиомы. Также важно знать установленные соглашения по программированию на Go, такие как именование, форматирование, структура программы и так далее, чтобы код, который вы пишете, был понятен другим программистам на Go.

Этот документ содержит советы по написанию понятного, идиоматического кода на Go. Он дополняет [спецификацию языка](https://go.dev/ref/spec), [Tour of Go](https://go.dev/tour/) и [How to Write Go Code](https://go.dev/doc/code.html), которые вам стоит прочитать в первую очередь.

**Примечание (январь 2022):** Этот документ был написан в 2009 году, когда выпускался Go, и с тех пор существенно не обновлялся. Хотя он является хорошим пособием для понимания самого языка благодаря его стабильности, он мало говорит о библиотеках и не затрагивает значительные изменения в экосистеме Go, такие как система сборки, тестирование, модули и полиморфизм. Обновление документа не планируется, так как появилось множество других ресурсов, блогов и книг, хорошо описывающих современное использование Go. "Effective Go" продолжает оставаться полезным, но его нельзя считать полным руководством. Подробнее см. [issue 28782](https://go.dev/issue/28782).

## Примеры

Исходный код [пакетов Go](https://go.dev/src/) предназначен не только для предоставления стандартной библиотеки, но и как примеры использования языка. Более того, многие пакеты содержат работающие, автономные исполняемые примеры, которые можно запустить прямо на сайте [go.dev](https://go.dev), например, [этот](https://pkg.go.dev/strings#example-Map) (при необходимости нажмите на слово "Example", чтобы раскрыть его). Если у вас есть вопрос о том, как подойти к решению проблемы или как что-то реализовать, документация, код и примеры в библиотеке могут помочь найти ответ, идеи и общий контекст.

## Форматирование

Вопросы форматирования наиболее спорные, но наименее значимые. Люди могут адаптироваться к разным стилям форматирования, но лучше, если им не придется этого делать. Если все следуют одному стилю, на обсуждение форматирования тратится меньше времени. Проблема в том, как достичь этой "утопии" без длинного предписывающего стиля кодирования.

В Go мы подошли к этому вопросу необычным способом и позволили машине взять на себя большинство проблем форматирования. Программа `gofmt` (также доступная как `go fmt`, который работает на уровне пакетов, а не отдельных файлов) читает код Go и приводит его к стандартному стилю с правильными отступами и вертикальным выравниванием, сохраняя и при необходимости переформатируя комментарии. Если вам нужно узнать, как правильно оформить код, запустите `gofmt`. Если результат не кажется правильным, лучше перестроить код (или сообщить о проблеме с `gofmt`), а не обходить её.

Например, нет необходимости вручную выравнивать комментарии к полям структуры. `gofmt` сделает это за вас. Исходное объявление:

```go
type T struct {
    name string // имя объекта
    value int // его значение
}
```

После форматирования с `gofmt` превратится в:

```go
type T struct {
    name    string // имя объекта
    value   int    // его значение
}
```

Весь код Go в стандартных пакетах был отформатирован с помощью `gofmt`.

### Основные принципы форматирования

- **Отступы**: Используйте табуляцию для отступов; `gofmt` делает это по умолчанию. Используйте пробелы только в крайнем случае.
- **Длина строки**: В Go нет ограничения на длину строки. Не переживайте, что код выйдет за пределы перфомапы. Если строка кажется слишком длинной, перенесите её с дополнительным отступом.
- **Скобки**: В Go требуется меньше скобок, чем в C и Java: управляющие структуры (`if`, `for`, `switch`) не требуют скобок в синтаксисе. Кроме того, приоритет операторов проще и понятнее, поэтому:

```go
x << 8 + y << 16
```

означает то, что предполагает отступ, в отличие от других языков.

## Комментарии

Go поддерживает блочные комментарии `/* */`, как в C, и строковые комментарии `//`, как в C++. Основным стилем являются строковые комментарии; блочные комментарии в основном используются для комментариев к пакетам, но могут быть полезны внутри выражений или для отключения большого куска кода.

Комментарии, которые находятся перед объявлениями на верхнем уровне (без пустых строк между ними), считаются документирующими комментариями. Они являются основным способом документирования пакетов и команд Go. Подробнее см. [Go Doc Comments](https://go.dev/doc/comment).

## Имена

Имена в Go так же важны, как и в любом другом языке. Более того, они несут семантическую нагрузку: видимость имени за пределами пакета определяется тем, начинается ли оно с заглавной буквы. Поэтому стоит потратить немного времени на обсуждение соглашений об именовании в Go-программах.

### Имена пакетов

Когда пакет импортируется, его имя становится способом обращения к его содержимому. Например, после:

```go
import "bytes"
```

импортирующий пакет может использовать `bytes.Buffer`. Полезно, если все, кто использует этот пакет, могут обращаться к его содержимому по одному и тому же имени. Это означает, что имя пакета должно быть хорошим: коротким, лаконичным, выразительным. По соглашению, имена пакетов пишутся в нижнем регистре, одним словом; не должно быть необходимости в подчеркиваниях или смешанных регистрах (`mixedCaps`).

Лучше выбирать короткие имена, ведь их придется набирать пользователям пакета. И не беспокойтесь заранее о возможных конфликтах. Имя пакета — это всего лишь имя по умолчанию для импорта; оно не обязано быть уникальным во всем исходном коде. В редких случаях коллизий импортирующий пакет может выбрать другое локальное имя. В любом случае, путаница случается редко, так как путь к файлу в `import` однозначно определяет, какой пакет используется.

Еще одно соглашение: имя пакета должно совпадать с базовым именем его исходного каталога. Например, пакет, находящийся в `src/encoding/base64`, импортируется как `"encoding/base64"`, но его имя — `base64`, а не `encoding_base64` или `encodingBase64`.

Импортирующий пакет использует имя для обращения к содержимому, поэтому экспортируемые имена в пакете могут учитывать это, чтобы избежать повторений. (Не используйте `import .`, за исключением тестов, которые должны выполняться вне пакета, который они тестируют — в остальных случаях это не рекомендуется). Например, тип буферизированного чтения в пакете `bufio` называется `Reader`, а не `BufReader`, потому что пользователи видят его как `bufio.Reader`, что понятно и лаконично. Более того, поскольку импортируемые сущности всегда адресуются с именем их пакета, `bufio.Reader` не конфликтует с `io.Reader`.

Аналогично, функция, создающая новые экземпляры `ring.Ring` (что в Go фактически является конструктором), обычно называлась бы `NewRing`, но поскольку `Ring` — единственный экспортируемый тип в этом пакете, а сам пакет называется `ring`, ее имя просто `New`. В результате пользователи видят `ring.New`, что выглядит логично. Используйте структуру пакетов, чтобы помогать себе выбирать хорошие имена.

Еще один короткий пример: `once.Do`. Вызов `once.Do(setup)` выглядит хорошо и не стал бы лучше, если бы назывался `once.DoOrWaitUntilDone(setup)`. Длинные имена не делают код автоматически понятнее. Часто полезнее написать хороший комментарий, чем использовать чрезмерно длинное имя.

### Геттеры

Go не предоставляет автоматической поддержки геттеров и сеттеров. Нет ничего плохого в их использовании, и иногда это вполне оправдано, но в Go не принято добавлять `Get` в название геттера. Если у вас есть поле `owner` (с маленькой буквы, неэкспортируемое), метод-геттер должен называться `Owner` (с большой буквы, экспортируемый), а не `GetOwner`. Использование заглавных букв для экспорта позволяет отличать поле от метода.

Если нужен сеттер, он, скорее всего, будет называться `SetOwner`. В реальном коде такие имена выглядят естественно:

```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### Имена интерфейсов

По соглашению, одно-методные интерфейсы получают имена, образованные от имени метода с суффиксом `-er` или аналогичным преобразованием, создающим имя агента: `Reader`, `Writer`, `Formatter`, `CloseNotifier` и так далее.

Существует множество таких имен, и полезно следовать этому соглашению, а также учитывать имена соответствующих функций. Например, `Read`, `Write`, `Close`, `Flush`, `String` и другие имеют канонические сигнатуры и значения. Чтобы избежать путаницы, не называйте метод так же, если он не имеет того же смысла и сигнатуры.

И наоборот, если ваш тип реализует метод с тем же значением, что и у хорошо известного типа, дайте ему такое же имя и сигнатуру. Например, метод преобразования в строку должен называться `String`, а не `ToString`.

### Смешанный регистр (MixedCaps)

Наконец, в Go принято использовать `MixedCaps` или `mixedCaps` вместо подчеркиваний для записи составных имен.

### Точка с запятой (Semicolons)

Как и в C, в формальной грамматике Go точка с запятой используется для завершения операторов, но в отличие от C, эти точки с запятой не присутствуют в исходном коде. Вместо этого лексер автоматически вставляет точки с запятой по простому правилу во время сканирования кода, поэтому в исходном тексте они встречаются редко.

Правило следующее: если последний токен перед новой строкой является идентификатором (что включает такие слова, как `int` и `float64`), базовым литералом (например, числом или строковой константой) или одним из следующих токенов:

```
break continue fallthrough return ++ -- ) }
```

то лексер всегда вставляет точку с запятой после этого токена. Это можно выразить так: «если новая строка появляется после токена, который может завершать оператор, вставьте точку с запятой».

Также точка с запятой может быть опущена непосредственно перед закрывающей фигурной скобкой, поэтому в коде, например:

```go
go func() { for { dst <- <-src } }()
```

точки с запятой не нужны.  

Идиоматичный код на Go содержит точки с запятой только в местах, таких как выражения в `for`-циклах, где они разделяют инициализатор, условие и выражение обновления. Также они необходимы для разделения нескольких операторов в одной строке, если вы решили писать код таким образом.

Одно из следствий правила вставки точек с запятой — нельзя начинать новую строку с открывающей фигурной скобки (`{`) после управляющих конструкций (`if`, `for`, `switch`, `select`). В противном случае перед `{` будет вставлена точка с запятой, что приведет к нежелательному поведению. Например, нужно писать так:

```go
if i < f() {
    g()
}
```

а не так:

```go
if i < f()  // неправильно!
{           // неправильно!
    g()
}
```

### Управляющие конструкции (Control structures)

Управляющие конструкции в Go схожи с таковыми в C, но имеют важные отличия. В языке отсутствуют `do` и `while`, вместо них используется более универсальный `for`. `switch` более гибкий. `if` и `switch` поддерживают необязательный оператор инициализации, как `for`. Операторы `break` и `continue` могут принимать метку, указывающую, к какому циклу они относятся. Также в Go есть новые управляющие конструкции, включая `type switch` и многоканальный селектор `select`.

Синтаксис также немного отличается: нет круглых скобок `()` вокруг условий, а тела всех управляющих конструкций должны быть заключены в фигурные скобки `{}`.

### `if`

В Go простое условие `if` выглядит так:

```go
if x > 0 {
    return y
}
```

Обязательное использование фигурных скобок `{}` поощряет написание `if`-конструкций в многострочном формате. Это хороший стиль, особенно если тело `if` содержит управляющие операторы, такие как `return` или `break`.

Поскольку `if` и `switch` поддерживают оператор инициализации, часто можно увидеть его использование для создания локальной переменной:

```go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
```

В стандартных библиотеках Go можно заметить, что если `if`-блок заканчивается оператором `return`, `break`, `continue` или `goto`, то ненужный `else` опускается:

```go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
```

Этот стиль особенно удобен, когда нужно обработать последовательность возможных ошибок. Код становится более читаемым, если успешное выполнение программы проходит сверху вниз, устраняя ошибки по мере их появления. Поскольку обработка ошибок обычно заканчивается `return`, необходимость в `else` просто отпадает:

```go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
```

### Переназначение переменных (`:=`)

Следующий пример демонстрирует, как работает короткое объявление переменных `:=`:

```go
f, err := os.Open(name)
```

Здесь объявляются две переменные: `f` и `err`. Позже в коде появляется:

```go
d, err := f.Stat()
```

Хотя `err` уже была объявлена ранее, это не является ошибкой. В данном случае `err` не объявляется заново, а просто получает новое значение. Это возможно, если:

1. Новое объявление находится в той же области видимости, что и существующая переменная `v` (если `v` объявлена во внешней области, создается новая переменная).
2. Присваиваемое значение совместимо с существующей переменной `v`.
3. В `:=` объявлении присутствует хотя бы одна новая переменная.

Эта особенность полезна в длинных цепочках `if-else`, где часто переиспользуется переменная `err`.

### `for`

Цикл `for` в Go схож с аналогом в C, но отличается в деталях. В языке отсутствуют `while` и `do-while`, но `for` объединяет их функциональность. В Go существуют три формы `for`, только одна из которых использует точки с запятой:

```go
// Как `for` в C
for init; condition; post { }

// Как `while` в C
for condition { }

// Бесконечный цикл
for { }
```

Короткие объявления позволяют удобно объявлять переменную индекса прямо в цикле:

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

#### `range`

Если нужно перебрать элементы массива, среза, строки, мапы или прочитать данные из канала, можно использовать `range`:

```go
for key, value := range oldMap {
    newMap[key] = value
}
```

Если нужен только первый элемент (`ключ` или `индекс`), можно опустить второй:

```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```

Если нужен только второй элемент (`значение`), используют **пустой идентификатор** `_`, чтобы проигнорировать первый:

```go
sum := 0
for _, value := range array {
    sum += value
}
```

#### `range` и строки

При переборе строк `range` разбивает их на отдельные **Unicode-кодовые точки** (руны), автоматически декодируя UTF-8. Ошибочные байты заменяются на U+FFFD (символ «�»). Например:

```go
for pos, char := range "日本\x80語" { // \x80 — недопустимая кодировка UTF-8
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
```

Выведет:

```
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
```

#### Несколько переменных в `for`

Go не поддерживает оператор `,` как в C, а `++` и `--` являются операторами, а не выражениями. Поэтому, если нужно обновлять несколько переменных в `for`, следует использовать **параллельное присваивание**:

```go
// Реверс массива a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
```

### `switch`

`switch` в Go более универсален, чем в C. Выражения в `case` не обязательно должны быть константами или целыми числами. Кейсы (`case`) проверяются сверху вниз, пока не будет найдено совпадение. Если `switch` не имеет выражения, он переключается по `true`, что делает его удобной заменой `if-else-if-else` цепочек.

Пример:

```go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
```

В Go **нет автоматического перехода (fallthrough) к следующему case**, но можно указывать несколько значений через запятую:

```go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
```

Хотя операторы `break` в Go не так часто встречаются, как в C, их можно использовать для принудительного выхода из `switch`. Однако иногда необходимо выйти не только из `switch`, но и из внешнего цикла. В Go это можно сделать с помощью **метки**:

```go
Loop:
    for n := 0; n < len(src); n += size {
        switch {
        case src[n] < sizeOne:
            if validateOnly {
                break // выход только из switch
            }
            size = 1
            update(src[n])

        case src[n] < sizeTwo:
            if n+1 >= len(src) {
                err = errShortInput
                break Loop // выход из for
            }
            if validateOnly {
                break
            }
            size = 2
            update(src[n] + src[n+1]<<shift)
        }
    }
```

Также оператор `continue` может использовать метку, но применяется только к циклам.

Закончим этот раздел примером функции сравнения срезов байтов, которая использует `switch`:

```go
// Compare возвращает целое число, сравнивающее два среза байтов лексикографически.
// Лексикографическое сравнение — это метод сравнения строк или массивов, 
// который аналогичен порядку слов в словаре. В данном контексте, лексикографическое 
// сравнение двух срезов байтов означает, что они сравниваются поэлементно, 
// начиная с первого элемента, и продолжается до тех пор, 
// пока не будет найдено различие или не закончится один из срезов.
// Результат будет 0, если a == b, -1, если a < b, и +1, если a > b.
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
```

### `type switch`

`switch` также можно использовать для определения **динамического типа** переменной интерфейса. Такой **type switch** использует синтаксис приведения типа, но с ключевым словом `type` в скобках. Если в `switch` объявляется переменная, она будет иметь соответствующий тип в каждом `case`.

В Go принято **использовать одно и то же имя переменной** при обработке разных типов, что фактически создает новую переменную с таким же именем, но другим типом в каждом `case`.

Пример:

```go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T выводит тип t
case bool:
    fmt.Printf("boolean %t\n", t)             // t имеет тип bool
case int:
    fmt.Printf("integer %d\n", t)             // t имеет тип int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t имеет тип *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t имеет тип *int
}
```

Это позволяет легко обрабатывать разные типы переменной, избегая громоздких `if-else`.

### Функции

#### Несколько возвращаемых значений

Одна из необычных особенностей Go заключается в том, что функции и методы могут возвращать несколько значений. Это позволяет улучшить некоторые громоздкие идиомы, встречающиеся в программах на C: например, возврат ошибок в пределах значений (in-band error returns), таких как `-1` для `EOF`, а также изменение аргументов, передаваемых по адресу.

В C ошибка записи сигнализируется отрицательным количеством записанных байтов, а сам код ошибки скрывается в нестабильном (volatile) месте. В Go метод `Write` может возвращать количество записанных байтов *и* ошибку: «Да, ты записал некоторые байты, но не все, потому что заполнил устройство». Сигнатура метода `Write` для файлов из пакета `os`:

```go
func (file *File) Write(b []byte) (n int, err error)
```

Как указано в документации, этот метод возвращает количество записанных байтов и ненулевую ошибку (`error`), если `n != len(b)`. Это распространённый стиль, и больше примеров можно найти в разделе обработки ошибок.

Аналогичный подход устраняет необходимость передавать указатель на возвращаемое значение, чтобы имитировать параметр-ссылку. Вот простейшая функция, которая извлекает число из байтового среза, начиная с указанной позиции, и возвращает найденное число вместе со следующей позицией:

```go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
```

Можно использовать её для сканирования чисел во входном срезе `b` так:

```go
for i := 0; i < len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
```

### Именованные возвращаемые параметры

Возвращаемые параметры (результаты) функции в Go могут быть именованными и использоваться как обычные переменные, аналогично входным параметрам. При этом, если они названы, то при запуске функции они инициализируются нулевыми значениями своих типов. Если в `return` не указывать аргументы, будут возвращены текущие значения этих переменных.

Имена не являются обязательными, но они могут сделать код более лаконичным и понятным — по сути, они служат документацией. Например, если именовать результаты `nextInt`, сразу становится понятно, какой из возвращаемых `int` за что отвечает:

```go
func nextInt(b []byte, pos int) (value, nextPos int) {
```

Так как именованные результаты инициализируются и связаны с неуточнённым `return`, это не только улучшает читаемость, но и упрощает код. Например, вот версия `io.ReadFull`, которая использует этот приём:

```go
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```

### `defer`

Оператор `defer` в Go откладывает выполнение вызова функции (так называемой *отложенной* функции) до того момента, когда окружающая её функция завершится и начнёт возвращаться. Это необычный, но эффективный способ работы с ресурсами, которые необходимо освободить, независимо от того, какой путь выполнения приведёт к завершению функции. Классические примеры — разблокировка мьютекса или закрытие файла.

Пример:

```go
// Contents возвращает содержимое файла в виде строки.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close вызовется, когда функция завершится.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append будет разобран позже.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f будет закрыт, если мы выйдем здесь.
        }
    }
    return string(result), nil // f будет закрыт при выходе из функции.
}
```

Использование `defer` для вызова `Close` даёт два преимущества. Во-первых, это гарантирует, что файл всегда будет закрыт, даже если в будущем появятся новые пути выхода из функции. Во-вторых, строка с `defer` находится рядом с `Open`, что делает код более читаемым.

Аргументы отложенной функции (включая получатель, если функция является методом) вычисляются в момент выполнения `defer`, а не в момент фактического вызова. Это предотвращает проблемы, связанные с изменением значений переменных в процессе выполнения функции, и позволяет использовать `defer` для вызова нескольких функций из одной точки. Вот забавный пример:

```go
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
```

Отложенные функции выполняются в порядке LIFO (Last In, First Out), так что этот код напечатает `4 3 2 1 0`, когда функция завершится.

Более практичное применение `defer` — это простой способ трассировки выполнения функций. Рассмотрим такой код:

```go
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Использование:
func a() {
    trace("a")
    defer untrace("a")
    // делаем что-то...
}
```

Можно улучшить этот механизм, воспользовавшись тем, что аргументы отложенных функций вычисляются в момент `defer`, а не в момент вызова. Это позволяет подготовить аргумент для завершающей функции:

```go
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
```

Вывод:

```
entering: b
in b
entering: a
in a
leaving: a
leaving: b
```

Для программистов, привыкших к управлению ресурсами на уровне блоков в других языках, `defer` может показаться странным. Однако его мощь и удобство проявляются именно в том, что он работает на уровне всей функции, а не блока кода. В разделе о `panic` и `recover` мы увидим ещё один интересный пример его использования.

## Данные

### Выделение памяти с помощью `new`

Go имеет два примитива для выделения памяти: встроенные функции `new` и `make`. Они выполняют разные задачи и применяются к разным типам, что может сбивать с толку, но правила их использования просты.

Сначала рассмотрим `new`. Это встроенная функция, которая выделяет память, но, в отличие от аналогов в некоторых других языках, она **не инициализирует** память, а только **заполняет её нулями**. То есть вызов:

```go
new(T)
```

выделяет память для нового элемента типа `T`, заполняет её нулями и возвращает его адрес, то есть значение типа `*T`. В терминологии Go это означает, что `new` возвращает указатель на вновь выделенное значение типа `T`, установленное в его нулевое значение.

Поскольку память, возвращаемая `new`, обнулена, полезно проектировать структуры данных так, чтобы их нулевые значения были полезными без дополнительной инициализации. Это позволяет пользователю создавать экземпляр с помощью `new` и сразу же начинать работу.

Например, документация к `bytes.Buffer` указывает, что «нулевое значение `Buffer` — это пустой буфер, готовый к использованию». Аналогично, `sync.Mutex` не имеет явного конструктора или метода `Init`. Вместо этого нулевое значение `sync.Mutex` определено как разблокированный мьютекс.

Свойство «нулевое значение полезно» распространяется и на составные структуры. Рассмотрим следующее объявление типа:

```go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
```

Экземпляры типа `SyncedBuffer` готовы к использованию сразу после выделения памяти или просто объявления. В следующем фрагменте кода обе переменные, `p` и `v`, будут корректно работать без дополнительной подготовки:

```go
p := new(SyncedBuffer)  // тип *SyncedBuffer
var v SyncedBuffer      // тип  SyncedBuffer
```

### Конструкторы и составные литералы

Иногда нулевого значения недостаточно, и необходим конструктор с инициализацией, как в этом примере, взятом из пакета `os`:

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
```

Здесь много шаблонного кода. Мы можем упростить его, используя **составной литерал** — выражение, создающее новый экземпляр при каждом выполнении:

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

Обратите внимание: в отличие от C, возвращать адрес локальной переменной в Go совершенно нормально — память, связанная с переменной, остается доступной после выхода из функции.

Фактически, взятие адреса составного литерала выделяет новую копию каждый раз, поэтому можно объединить последние две строки:

```go
return &File{fd, name, nil, 0}
```

Поля составного литерала располагаются в порядке объявления и должны присутствовать все. Однако, если их явно именовать в формате `<поле>: <значение>`, порядок можно изменить, а пропущенные значения останутся нулевыми:

```go
return &File{fd: fd, name: name}
```

В крайнем случае, если составной литерал не содержит полей, он создаёт нулевое значение типа. Таким образом, выражения `new(File)` и `&File{}` эквивалентны.

Составные литералы можно использовать и для массивов, срезов и отображений, где метками выступают индексы или ключи:

```go
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
```

### Выделение памяти с помощью `make`

Вернемся к выделению памяти. Встроенная функция `make(T, args)` выполняет другую задачу, нежели `new(T)`. Она используется **только** для создания срезов, отображений (map) и каналов и возвращает **инициализированное** (а не просто нулевое) значение типа `T` (а не `*T`).

Различие связано с тем, что эти три типа в Go на самом деле являются ссылками на внутренние структуры данных, которые **должны быть инициализированы перед использованием**.

Например, срез представляет собой структуру из трёх элементов:

- указатель на массив данных,
- длину,
- вместимость.

До инициализации срез равен `nil`. Функция `make` создаёт внутреннюю структуру и подготавливает её к использованию:

```go
make([]int, 10, 100)
```

Этот вызов выделяет массив из 100 целых чисел и создаёт структуру среза длиной 10 и вместимостью 100, указывающую на первые 10 элементов массива.

(При создании среза вместимость можно опустить; подробнее об этом в разделе о срезах.)

В отличие от этого, `new([]int)` просто возвращает **указатель на нулевую структуру среза**, то есть указатель на `nil`-значение среза.

Эти примеры показывают разницу между `new` и `make`:

```go
var p *[]int = new([]int)       // выделяет структуру среза; *p == nil; редко используется
var v  []int = make([]int, 100) // срез v теперь ссылается на новый массив из 100 целых чисел

// Излишне сложный вариант:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Идиоматичный Go-код:
v := make([]int, 100)
```

Помните, что `make` применяется **только** к мапам, срезам и каналам и **не возвращает указатель**. Чтобы получить явный указатель, используйте `new` или берите адрес переменной явно.

### **Массивы (Arrays)**

Массивы полезны при детальном планировании размещения памяти и иногда помогают избежать выделения памяти. Однако в первую очередь они являются строительным блоком для срезов (slices), которые обсуждаются в следующем разделе. Чтобы заложить основу для этой темы, разберёмся с массивами.

Существенные различия между массивами в Go и C:

- **Массивы являются значениями.** При присваивании одного массива другому копируются все его элементы.
- **Если передать массив в функцию, она получит его **копию**, а не указатель на него.**
- **Размер массива является частью его типа.** Например, типы `[10]int` и `[20]int` считаются разными.

Такое поведение может быть полезным, но иногда дорогим по производительности. Если требуется поведение, похожее на C, можно передавать указатель на массив:

```go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Обратите внимание на оператор взятия адреса
```

Однако даже этот стиль не является идиоматичным для Go. Лучше использовать **срезы**.

### **Срезы (Slices)**

Срезы оборачивают массивы, предоставляя более общий, мощный и удобный интерфейс для работы с последовательностями данных. За исключением случаев, когда размер важен (например, матрицы преобразования), в Go чаще работают со срезами, а не с массивами.

Срезы **содержат ссылки на базовый массив**, а не копию данных. Поэтому при присваивании одного среза другому оба среза будут ссылаться на один и тот же массив. Если передать срез в функцию, изменения внутри него будут видны вызывающей стороне, аналогично передаче указателя на массив. Например, метод `Read` из пакета `os` принимает срез, а не указатель и счётчик:

```go
func (f *File) Read(buf []byte) (n int, err error)
```

Этот метод возвращает количество прочитанных байтов и возможную ошибку. Чтобы считать первые 32 байта в буфер `buf`, можно использовать срез:

```go
n, err := f.Read(buf[0:32])
```

Такой способ эффективен и широко используется. Альтернативный способ (менее эффективный):

```go
var n int
var err error
for i := 0; i < 32; i++ {
    nbytes, e := f.Read(buf[i : i+1]) // Читаем по 1 байту.
    n += nbytes
    if nbytes == 0 || e != nil {
        err = e
        break
    }
}
```

Размер среза можно изменять, если он укладывается в границы базового массива. Функция `cap(slice)` возвращает максимальную возможную длину среза. Пример функции для добавления данных в срез:

```go
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l+len(data) > cap(slice) {  // Нужно перевыделение памяти
        // Выделяем в 2 раза больше, чем требуется, для будущего роста.
        newSlice := make([]byte, (l+len(data))*2)
        copy(newSlice, slice) // Копируем старые данные
        slice = newSlice
    }
    slice = slice[0 : l+len(data)]
    copy(slice[l:], data)
    return slice
}
```

Функция возвращает новый срез, так как сам объект среза (указатель, длина и ёмкость) передаётся по значению.

Идея добавления элементов в срез настолько полезна, что встроена в Go через функцию `append`, к которой мы ещё вернёмся позже.

### **Двумерные срезы (Two-dimensional slices)**

В Go массивы и срезы — **одномерные**. Для работы с двумерными структурами используют **массив массивов** или **срез срезов**, например:

```go
type Transform [3][3]float64  // 3×3 массив, на самом деле массив массивов.
type LinesOfText [][]byte     // Срез срезов байтов.
```

Так как срезы имеют переменную длину, вложенные срезы могут быть разной длины, что полезно, например, для хранения строк разной длины:

```go
text := LinesOfText{
    []byte("Now is the time"),
    []byte("for all good gophers"),
    []byte("to bring some fun to the party."),
}
```

Иногда требуется **выделить память для 2D-среза**, например, при обработке изображений. Можно сделать это двумя способами:

1. **Создавать каждый вложенный срез отдельно** (гибкость, но больше затрат памяти):

```go
// Выделяем верхний срез
picture := make([][]uint8, YSize) // Одна строка на каждое значение Y.
// Выделяем память для каждой строки отдельно
for i := range picture {
    picture[i] = make([]uint8, XSize)
}
```

2. **Выделить один массив и разрезать его на подмассивы** (меньше аллокаций, но фиксированные размеры строк):

```go
// Выделяем верхний срез
picture := make([][]uint8, YSize)
// Выделяем один большой массив под все пиксели
pixels := make([]uint8, XSize*YSize) 
// Заполняем верхний срез ссылками на нужные части массива pixels
for i := range picture {
    picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
```

Какой метод выбрать, зависит от задачи: если строки должны менять длину — первый вариант, если размер фиксирован — второй вариант будет эффективнее.

### Мапы (Maps)

Мапы (maps) — это удобная и мощная встроенная структура данных, которая связывает значения одного типа (ключ, *key*) со значениями другого типа (элемент, *element* или значение, *value*).  

Ключ может быть любого типа, для которого определён оператор равенства, например:

- целые числа,
- числа с плавающей запятой и комплексные числа,
- строки,
- указатели,
- интерфейсы (если их динамический тип поддерживает сравнение на равенство),
- структуры и массивы.

Срезы (*slices*) нельзя использовать в качестве ключей мап, потому что для них не определено понятие равенства.  

Как и срезы, мапы хранят ссылки на внутреннюю структуру данных. Если передать мапу в функцию и изменить её содержимое, изменения будут видны в вызывающем коде.

#### Создание мапы

Мапы можно создавать с помощью стандартного синтаксиса составных литералов, используя пары "ключ-значение", разделённые двоеточием. Это позволяет легко инициализировать мапу.

```go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
```

#### Доступ к элементам мапы

Присваивание значений и доступ к элементам мапы синтаксически похожи на работу с массивами и срезами, за исключением того, что индекс (ключ) может быть не только числом.

```go
offset := timeZone["EST"]
```

Если попытаться получить значение по ключу, которого нет в мапе, будет возвращено **нулевое значение** для типа элементов мапы. Например, если мапа содержит целые числа, а ключ отсутствует, вернётся `0`.

### Использование мапы как множества (set)

Множество можно реализовать с помощью мапы, где типом значений будет `bool`. Чтобы добавить элемент в множество, достаточно установить для ключа значение `true`, а для проверки существования элемента можно использовать обычное индексирование:

```go
attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // Будет false, если person нет в мапе
    fmt.Println(person, "был(а) на встрече")
}
```

### Отличие отсутствующего ключа от нулевого значения

Иногда важно различать, отсутствует ли ключ в мапе или он просто имеет нулевое значение. Например, как понять, содержится ли `"UTC"` в мапе, или же результат `0` означает, что такого ключа нет?  

Для этого можно использовать множественное присваивание:

```go
var seconds int
var ok bool
seconds, ok = timeZone[tz]
```

Этот подход называют *"идиома запятая-ok"*.  
Если ключ `tz` присутствует в мапе, `seconds` получит соответствующее значение, а `ok` будет `true`.  
Если ключ отсутствует, `seconds` будет `0`, а `ok` — `false`.

Пример функции, использующей этот подход для обработки ошибок:

```go
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("неизвестный часовой пояс:", tz)
    return 0
}
```

### Проверка наличия ключа без получения значения

Если нужно только проверить, присутствует ли ключ в мапе, но само значение не важно, можно использовать **пустой идентификатор** (`_`):

```go
_, present := timeZone[tz]
```

### Удаление элементов из мапы

Для удаления элемента из мапы используется встроенная функция `delete()`, которая принимает мапу и ключ, который нужно удалить. Это безопасная операция, даже если ключ уже отсутствует в мапе.

```go
delete(timeZone, "PDT")  // Теперь используем стандартное время
```

### Печать (Printing)

Форматированный вывод в Go использует стиль, похожий на семейство функций `printf` в C, но он более гибкий и универсальный. Эти функции находятся в пакете `fmt` и имеют названия с заглавной буквы: `fmt.Printf`, `fmt.Fprintf`, `fmt.Sprintf` и так далее. Функции, работающие со строками (например, `Sprintf`), возвращают строку вместо записи в предоставленный буфер.

#### Функции без форматной строки

Использование форматной строки не обязательно. Для каждой из функций `Printf`, `Fprintf` и `Sprintf` есть альтернативная пара функций, например, `Print` и `Println`. Эти функции не требуют форматной строки и автоматически подбирают формат для каждого аргумента. Версии `Println` также вставляют пробел между аргументами и добавляют новую строку в конец вывода, в то время как `Print` добавляет пробелы только в том случае, если операнд по обе стороны не является строкой. В следующем примере все строки кода выводят одинаковый результат:

```go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
```

Форматированные функции вывода (`fmt.Fprint` и другие) принимают первым аргументом любой объект, реализующий интерфейс `io.Writer`; переменные `os.Stdout` и `os.Stderr` являются распространёнными примерами.

#### Отличия от C

Здесь начинаются отличия от C. Например, числовые форматы, такие как `%d`, не используют флаги для знака или размера; вместо этого функции вывода определяют эти параметры по типу аргумента.

```go
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
```

Выведет:

```
18446744073709551615 ffffffffffffffff; -1 -1
```

Если нужен вывод в формате по умолчанию (например, десятичный для целых чисел), можно использовать универсальный спецификатор `%v` (от "value"). Он отображает значение так же, как `Print` и `Println`. Причём этот формат работает **для любого** значения, включая массивы, срезы, структуры и отображения:

```go
fmt.Printf("%v\n", timeZone)  // или просто fmt.Println(timeZone)
```

Результат:

```
map[CST:-21600 EST:-18000 MST:-25200 PST:-28800 UTC:0]
```

Для отображений (`map`) `Printf` и другие функции сортируют ключи в лексикографическом порядке.

#### Расширенные форматы вывода

При выводе структуры можно использовать модификаторы:

- `%+v` — добавляет названия полей структуры.
- `%#v` — выводит значение в полном синтаксисе Go.

Пример:

```go
type T struct {
    a int
    b float64
    c string
}
t := &T{7, -2.35, "abc\tdef"}
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
```

Выведет:

```
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string]int{"CST":-21600, "EST":-18000, "MST":-25200, "PST":-28800, "UTC":0}
```

(Обратите внимание на амперсанды `&`.)

Также можно использовать:

- `%q` — для безопасного строкового вывода (в кавычках).
- `%#q` — аналогично, но использует обратные кавычки, если возможно.
- `%x` — выводит данные в виде шестнадцатеричной строки (работает со строками, массивами и срезами байтов).
- `% x` (с пробелом) — добавляет пробелы между байтами.

#### Вывод типа значения

Спецификатор `%T` позволяет вывести **тип** переданного значения:

```go
fmt.Printf("%T\n", timeZone)
```

Результат:

```
map[string]int
```

### Управление форматом вывода для пользовательских типов

Если требуется контролировать формат вывода для пользовательского типа, достаточно определить у него метод с сигнатурой `String() string`. Для нашего простого типа `T` это может выглядеть так:

```go
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
```

Вывод будет следующим:

```
7/-2.35/"abc\tdef"
```

(Если необходимо выводить **значения** типа `T`, а также **указатели** на `T`, то метод `String` должен быть определён у значения типа `T`. В данном примере использовался указатель, так как это более эффективно и соответствует идиоматическому стилю работы со структурами. См. раздел ниже о [приёмниках-указателях и значениях](#pointers_vs_values) для получения дополнительной информации.)

### Взаимодействие `String()` и `Sprintf`

Метод `String` может вызывать `Sprintf`, так как функции печати в Go являются полностью **реентерабельными** и могут быть использованы таким образом. Однако есть важный момент: не следует реализовывать `String` так, чтобы вызов `Sprintf` приводил к **рекурсивному** вызову `String`, иначе это приведёт к бесконечной рекурсии. Это распространённая ошибка, пример которой приведён ниже.

```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Ошибка: бесконечная рекурсия!
}
```

### Как исправить бесконечную рекурсию

Ошибка возникает, потому что `fmt.Sprintf("%s", m)` снова вызывает `String()`, что приводит к бесконечному циклу. Исправленный вариант:

```go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // ОК: явное преобразование в string
}
```

В разделе [инициализация](#initialization) будет рассмотрен ещё один способ избежать этой проблемы.

### Передача аргументов в другие функции печати

Другой важный приём — передача аргументов из одной функции печати в другую. Функция `Printf` в Go принимает **переменное количество аргументов** (`variadic arguments`), определяемых через `...interface{}`:

```go
func Printf(format string, v ...interface{}) (n int, err error)
```

Внутри `Printf` переменная `v` ведёт себя как `[]interface{}`, но при передаче в другую вариативную функцию (например, `Sprintln`) её можно **развернуть**, добавив `...`, чтобы передать аргументы как отдельные значения.

Пример реализации `log.Println`, передающей аргументы напрямую в `fmt.Sprintln`:

```go
// Println печатает сообщение в стандартный логгер, аналогично fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output принимает параметры (int, string)
}
```

Если бы `v` передавалось **без** `...`, оно бы передавалось как **единственный срез** `[]interface{}`, а не как отдельные аргументы.

### Ещё больше возможностей форматированного вывода

Функции форматированной печати в Go обладают ещё большим количеством возможностей, чем рассмотрено здесь. Подробности можно найти в документации пакета `fmt`, используя `godoc`.

### Пример использования `...` с определённым типом

Переменное количество аргументов (`...`) может быть ограничено определённым типом. Например, функция `Min`, которая находит минимальное значение среди переданных целых чисел:

```go
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // наибольшее возможное значение int
    for _, i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
```

Здесь `a` — это список значений типа `int`, переданных в функцию. Эта функция находит наименьшее из них.

### Append

Теперь у нас есть недостающий элемент, необходимый для объяснения конструкции встроенной функции `append`. Сигнатура `append` отличается от нашей пользовательской функции `Append`, представленной выше. Схематически она выглядит так:

```go
func append(slice []<i>T</i>, elements ...<i>T</i>) []<i>T</i>
```

где `T` — это заполнитель для любого типа. Нельзя написать функцию в Go, в которой тип `T` определяется вызывающей стороной. Именно поэтому `append` является встроенной функцией: ей требуется поддержка со стороны компилятора.

Функция `append` добавляет элементы в конец среза и возвращает результат. Возвращение результата необходимо, поскольку, как и в нашем вручную написанном варианте `Append`, базовый массив может измениться. В этом простом примере:

```go
x := []int{1, 2, 3}
x = append(x, 4, 5, 6)
fmt.Println(x)
```

выводится: `[1 2 3 4 5 6]`. Таким образом, `append` работает немного похоже на `Printf`, собирая произвольное количество аргументов.

Но что если мы захотим сделать то же, что делает наша функция `Append`, и добавить один срез к другому? Это просто: используйте `...` при вызове, так же, как мы сделали это в вызове `Output` выше. Этот фрагмент кода приведёт к тому же результату, что и предыдущий:

```go
x := []int{1, 2, 3}
y := []int{4, 5, 6}
x = append(x, y...)
fmt.Println(x)
```

Без `...` этот код не скомпилируется, так как типы будут несовместимы; `y` не является значением типа `int`.

# Инициализация

Хотя на первый взгляд инициализация в Go не сильно отличается от C или C++, она обладает большей мощностью. В Go можно создавать сложные структуры во время инициализации, а вопросы порядка инициализации объектов, даже из разных пакетов, обрабатываются корректно.

## Константы

Константы в Go действительно являются неизменяемыми. Они создаются на этапе компиляции, даже если объявлены внутри функций, и могут представлять только числа, символы (руны), строки или булевы значения.  

Из-за этого ограничения выражения, определяющие константы, должны быть константными выражениями, которые компилятор может вычислить на этапе компиляции. Например,  
`1<<3` является константным выражением, тогда как  
`math.Sin(math.Pi/4)` — нет, потому что вызов функции `math.Sin` должен выполняться во время выполнения программы.

В Go перечислимые константы создаются с помощью перечислителя `iota`. Так как `iota` может быть частью выражения, а выражения могут неявно повторяться, это позволяет легко формировать сложные наборы значений.

```go
type ByteSize float64

const (
    _           = iota // игнорируем первое значение
    KB ByteSize = 1 << (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
```

Возможность привязывать методы, такие как `String`, к любым пользовательским типам позволяет автоматически форматировать значения для вывода. Хотя это чаще всего используется со структурами, такой подход полезен и для скалярных типов, например, для чисел с плавающей запятой, таких как `ByteSize`.

```go
func (b ByteSize) String() string {
    const format = "%.2f%s"
    switch {
    case b >= YB:
        return fmt.Sprintf(format, b/YB, "YB")
    case b >= ZB:
        return fmt.Sprintf(format, b/ZB, "ZB")
    case b >= EB:
        return fmt.Sprintf(format, b/EB, "EB")
    case b >= PB:
        return fmt.Sprintf(format, b/PB, "PB")
    case b >= TB:
        return fmt.Sprintf(format, b/TB, "TB")
    case b >= GB:
        return fmt.Sprintf(format, b/GB, "GB")
    case b >= MB:
        return fmt.Sprintf(format, b/MB, "MB")
    case b >= KB:
        return fmt.Sprintf(format, b/KB, "KB")
    }
    return fmt.Sprintf("%.2fB", b)
}
```

Выражение `YB` выводится как `1.00YB`, а `ByteSize(1e13)` — как `9.09TB`.

Использование `Sprintf` для реализации метода `String` в `ByteSize` безопасно (избегает бесконечной рекурсии) не из-за явного преобразования типов, а потому, что `Sprintf` вызывается с `"%f"`, а это не строковый формат. `Sprintf` вызывает метод `String` только тогда, когда ожидает строку, а `"%f"` требует число с плавающей запятой.

## Переменные

Переменные можно инициализировать так же, как константы, но их инициализатор может быть произвольным выражением, вычисляемым во время выполнения.

```go
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
```

## Функция `init`

Каждый исходный файл может содержать собственную функцию `init` без аргументов, предназначенную для настройки необходимого состояния. (Фактически, в одном файле может быть несколько функций `init`.)

Функция `init` вызывается после вычисления всех инициализаторов переменных в пакете, а они, в свою очередь, вычисляются только после инициализации всех импортированных пакетов.

Помимо инициализаций, которые невозможно выразить с помощью деклараций, распространённый случай использования `init` — проверка или исправление состояния программы перед её реальным выполнением.

```go
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath может быть переопределён через флаг --gopath в командной строке.
    flag.StringVar(&gopath, "gopath", gopath, "override default GOPATH")
}
```

### Методы

#### Указатели vs. Значения

Как мы видели на примере `ByteSize`, методы можно определять для любого именованного типа (кроме указателя или интерфейса); получатель метода (receiver) необязательно должен быть структурой.

В обсуждении срезов выше мы писали функцию `Append`. Мы можем определить её как метод для срезов. Для этого сначала объявим именованный тип, к которому можно привязать метод, а затем сделаем его получателем метода.

```go
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Тело метода точно такое же, как у функции Append, определённой ранее.
}
```

Однако такой метод по-прежнему вынужден возвращать обновлённый срез. Мы можем избавиться от этой неудобности, если переопределим метод так, чтобы он принимал **указатель** на `ByteSlice` в качестве получателя. Это позволит методу изменять переданный срез напрямую.

```go
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Тело остаётся тем же, но без возврата значения.
    *p = slice
}
```

Фактически, мы можем сделать ещё лучше. Если изменить сигнатуру метода так, чтобы он выглядел как стандартный метод `Write`, например:

```go
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Тело остаётся прежним.
    *p = slice
    return len(data), nil
}
```

то тип `*ByteSlice` начнёт удовлетворять стандартному интерфейсу `io.Writer`, что удобно. Например, теперь мы можем выводить в `ByteSlice`, как в буфер.

```go
var b ByteSlice
fmt.Fprintf(&b, "This hour has %d days\n", 7)
```

Здесь передаётся **адрес** `ByteSlice`, потому что только `*ByteSlice` удовлетворяет `io.Writer`.  
Правило относительно указателей и значений для получателей методов заключается в том, что методы значений можно вызывать как на указателях, так и на значениях,  
но методы указателей можно вызывать **только** на указателях.

Это правило существует потому, что методы указателей могут изменять получатель. Если бы такой метод вызывался на значении, он получил бы **копию** значения, а любые изменения пропали бы. Поэтому язык не позволяет совершить такую ошибку.

Однако есть удобное исключение. Когда значение **адресуемо**, язык автоматически подставляет оператор взятия адреса.  
В нашем примере переменная `b` адресуема, поэтому мы можем вызвать её метод `Write` просто как `b.Write`. Компилятор автоматически преобразует это в `(&b).Write`.

Кстати, идея использования `Write` для среза байтов лежит в основе реализации `bytes.Buffer`.

## Интерфейсы и другие типы

### Интерфейсы

В Go интерфейсы предоставляют способ задать поведение объекта: если что-то может делать *это*, значит, его можно использовать *здесь*. Мы уже видели несколько простых примеров: пользовательские принтеры могут быть реализованы через метод `String`, а `Fprintf` может выводить данные в любой объект, имеющий метод `Write`.  

В Go-коде часто встречаются интерфейсы, содержащие всего один или два метода. Обычно им дают имя, основанное на названии метода, например, `io.Writer` для объектов, реализующих метод `Write`.  

Тип может реализовывать несколько интерфейсов. Например, коллекция может быть отсортирована функциями из пакета `sort`, если она реализует `sort.Interface`, который содержит методы `Len()`, `Less(i, j int) bool` и `Swap(i, j int)`. При этом она также может иметь собственный метод форматирования.  

В этом искусственном примере `Sequence` удовлетворяет обоим требованиям.  

```go
type Sequence []int

// Методы, необходимые для реализации sort.Interface.
func (s Sequence) Len() int {
    return len(s) // Возвращает длину последовательности.
}
func (s Sequence) Less(i, j int) bool {
    return s[i] < s[j] // Определяет порядок элементов: меньший идёт первым.
}
func (s Sequence) Swap(i, j int) {
    s[i], s[j] = s[j], s[i] // Меняет местами два элемента.
}

// Copy возвращает копию последовательности.
func (s Sequence) Copy() Sequence {
    copy := make(Sequence, 0, len(s)) // Создаёт новый срез нужной длины.
    return append(copy, s...) // Копирует элементы в новый срез.
}

// Метод для форматированного вывода - сортирует элементы перед печатью.
func (s Sequence) String() string {
    s = s.Copy() // Создаём копию, чтобы не изменять оригинал.
    sort.Sort(s) // Сортируем последовательность.
    str := "["   // Начинаем формирование строки.
    for i, elem := range s { // Проходим по всем элементам (цикл O(N²), но это будет исправлено позже).
        if i > 0 {
            str += " " // Добавляем пробел между элементами.
        }
        str += fmt.Sprint(elem) // Преобразуем элемент в строку и добавляем.
    }
    return str + "]" // Закрываем строку и возвращаем результат.
}
```

Этот код:

1. Определяет тип `Sequence`, который является просто срезом `[]int`.
2. Реализует интерфейс `sort.Interface`, добавляя методы `Len()`, `Less()` и `Swap()`, чтобы `sort.Sort(s)` мог отсортировать последовательность.
3. В методе `Copy()` создаёт копию последовательности, чтобы избежать изменения оригинала.
4. В методе `String()` копирует последовательность, сортирует её и вручную форматирует в строку вида `"[1 2 3]"`. Цикл имеет сложность O(N²), но в следующих примерах это будет исправлено.

Этот код демонстрирует, как использовать интерфейсы и преобразования типов в Go для удобной работы с пользовательскими структурами данных.

### Преобразования

Метод `String` у `Sequence` фактически дублирует работу, которую уже выполняет `Sprint` для срезов. (Кроме того, его сложность — O(N²), что неэффективно.) Можно избежать этого и ускорить выполнение, если перед вызовом `Sprint` преобразовать `Sequence` в обычный `[]int`.  

```go
func (s Sequence) String() string {
    s = s.Copy()
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
```

Этот метод — ещё один пример техники преобразования типов для безопасного вызова `Sprintf` внутри метода `String`. Поскольку два типа (`Sequence` и `[]int`) совпадают, если игнорировать имя типа, их можно свободно преобразовывать друг в друга.  

Такое преобразование не создаёт новое значение, а просто временно рассматривает существующее значение как принадлежащее к другому типу. (Существуют и другие допустимые преобразования, например, из целого числа в число с плавающей запятой, которые действительно создают новые значения.)  

В Go распространён идиоматический приём: преобразовывать выражение в другой тип, чтобы получить доступ к другому набору методов.  

Например, можно использовать существующий тип `sort.IntSlice`, чтобы упростить весь пример до следующего варианта:  

```go
type Sequence []int

// Метод для форматированного вывода - сортирует элементы перед выводом
func (s Sequence) String() string {
    s = s.Copy()
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
```

Теперь вместо того, чтобы `Sequence` реализовывал несколько интерфейсов (сортировки и форматирования), мы используем возможность преобразовывать данные в несколько типов (`Sequence`, `sort.IntSlice` и `[]int`), каждый из которых выполняет свою часть задачи. Это менее распространённый, но вполне эффективный подход.

### Преобразования интерфейсов и утверждения типов

[Переключатели типов](#type_switch) являются формой преобразования: они принимают интерфейс и, для каждого случая в переключателе, в некотором смысле преобразуют его в тип этого случая. Вот упрощённая версия того, как код в `fmt.Printf` преобразует значение в строку, используя переключатель типов.  
Если это уже строка, нам нужно получить фактическое строковое значение, хранящееся в интерфейсе. Если же у значения есть метод `String`, мы хотим получить результат вызова этого метода.

```go
type Stringer interface {
    String() string
}

var value interface{} // Значение, переданное вызывающим кодом.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
```

В первом случае мы получаем конкретное значение; во втором – преобразуем интерфейс в другой интерфейс.  
Такое смешивание типов совершенно допустимо.

### Утверждения типов

Что если нам нужен только один конкретный тип? Например, если мы знаем, что значение хранит `string`, и просто хотим его извлечь?  
Можно использовать переключатель типов с одним случаем, но можно воспользоваться *утверждением типа*.

Утверждение типа берёт значение интерфейса и извлекает из него значение указанного явного типа.  
Синтаксис похож на открывающую конструкцию переключателя типов, но вместо `type` указывается конкретный тип:

```go
value.(typeName)
```

Результатом будет новое значение с статическим типом `typeName`. Этот тип должен быть либо конкретным типом, содержащимся в интерфейсе, либо другим интерфейсным типом, в который можно выполнить преобразование.  
Чтобы извлечь строку, которая, как мы знаем, находится в `value`, можно написать:

```go
str := value.(string)
```

Но если окажется, что `value` не содержит строку, программа аварийно завершится с ошибкой времени выполнения.  
Чтобы этого избежать, используют идиому `"запятая, ok"`, которая безопасно проверяет, является ли значение строкой:

```go
str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
```

Если утверждение типа не удалось, `str` всё равно будет существовать и иметь тип `string`, но его значение будет равно нулевому значению для строк — пустой строке.

Вот эквивалентная конструкция с `if`-`else`, аналогичная приведённому выше переключателю типов:

```go
if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
```

### Общность

Если тип существует только для реализации интерфейса и никогда не будет содержать экспортируемых методов помимо тех, что определены в интерфейсе, нет необходимости экспортировать сам тип.  
Экспортируя только интерфейс, становится очевидно, что значение не обладает никаким поведением, кроме описанного в интерфейсе.  
Кроме того, это позволяет избежать дублирования документации для каждого экземпляра общего метода.

В таких случаях конструктор должен возвращать значение интерфейса, а не конкретный реализующий тип.  

Например, в библиотеках для работы с хешами функции `crc32.NewIEEE` и `adler32.New` возвращают значение интерфейса `hash.Hash32`.  
Замена алгоритма CRC-32 на Adler-32 в программе на Go требует только изменения вызова конструктора, а остальной код остаётся неизменным.

Аналогичный подход используется для потоковых алгоритмов шифрования в различных пакетах `crypto`, которые отделяют потоковые шифры от блочных, на которых они основаны.  
Интерфейс `Block` в пакете `crypto/cipher` определяет поведение блочного шифра, который выполняет шифрование одного блока данных.  

По аналогии с пакетом `bufio`, пакеты шифрования, реализующие этот интерфейс, могут использоваться для построения потоковых шифров, представленных интерфейсом `Stream`, без необходимости разбираться в деталях блочного шифрования.

Интерфейсы из `crypto/cipher` выглядят так:

```go
type Block interface {
    BlockSize() int
    Encrypt(dst, src []byte)
    Decrypt(dst, src []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
```

Вот определение режима счётчика (CTR), который превращает блочный шифр в потоковый. Обратите внимание, что детали блочного шифра остаются скрытыми:

```go
// NewCTR возвращает Stream, который шифрует/дешифрует с использованием
// переданного Block в режиме счётчика. Длина iv должна совпадать с размером блока Block.
func NewCTR(block Block, iv []byte) Stream
```

`NewCTR` применяется не к конкретному алгоритму шифрования и источнику данных, а к любой реализации интерфейса `Block` и любому `Stream`.  
Поскольку эти функции возвращают интерфейсные значения, замена шифрования CTR на другой режим шифрования – это локальное изменение.  
Нужно изменить только вызовы конструкторов, но остальной код продолжит работать, так как он оперирует с `Stream`, а не с конкретной реализацией.

### Интерфейсы и методы

Поскольку к почти любому объекту можно прикрепить методы, почти любой объект может удовлетворять интерфейсу. Один из показательных примеров находится в пакете `http`, который определяет интерфейс `Handler`. Любой объект, реализующий `Handler`, может обрабатывать HTTP-запросы.

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

`ResponseWriter` сам по себе является интерфейсом, предоставляющим доступ к методам, необходимым для отправки ответа клиенту. Эти методы включают стандартный метод `Write`, поэтому `http.ResponseWriter` можно использовать везде, где требуется `io.Writer`.  
`Request` — это структура, содержащая разобранное представление запроса от клиента.

Для краткости давайте проигнорируем запросы типа POST и будем считать, что все HTTP-запросы являются GET-запросами; это упрощение никак не повлияет на способ настройки обработчиков.  
Вот простой обработчик, который подсчитывает количество посещений страницы:

```go
// Простой сервер-счётчик.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
```

(Обратите внимание, что `Fprintf` может печатать в `http.ResponseWriter`.)  
В реальном сервере доступ к `ctr.n` необходимо защитить от конкурентного доступа. Смотрите пакеты `sync` и `atomic` для решения этой проблемы.

Для справки, вот как можно привязать такой сервер к узлу в URL-дереве:

```go
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
```

Но зачем делать `Counter` структурой? Ведь достаточно просто целого числа.  
(При этом получатель должен быть указателем, чтобы инкремент был виден вызывающему коду.)

```go
// Более простой сервер-счётчик.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
```

А что, если у программы есть какое-то внутреннее состояние, которое нужно уведомлять о посещении страницы? Можно привязать канал к веб-странице:

```go
// Канал, отправляющий уведомление при каждом посещении.
// (Вероятно, канал стоит сделать буферизированным.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch <- req
    fmt.Fprint(w, "notification sent")
}
```

Теперь предположим, что мы хотим на странице `/args` отображать аргументы, с которыми был запущен бинарный сервер.  
Написать функцию для вывода аргументов просто:

```go
func ArgServer() {
    fmt.Println(os.Args)
}
```

Но как превратить её в HTTP-сервер? Мы могли бы сделать `ArgServer` методом какого-то типа, но есть более элегантное решение.  
Поскольку в Go можно определять методы для любого типа (кроме указателей и интерфейсов), мы можем написать метод для функции. В пакете `http` есть следующий код:

```go
// Тип HandlerFunc является адаптером, позволяющим использовать
// обычные функции в качестве HTTP-обработчиков. Если f — функция
// с подходящей сигнатурой, то HandlerFunc(f) становится
// объектом Handler, который вызывает f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP вызывает f(w, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
```

`HandlerFunc` — это тип с методом `ServeHTTP`, а значит, значения этого типа могут обрабатывать HTTP-запросы.  
Посмотрите на реализацию метода: его получатель — это функция `f`, и метод просто вызывает `f`. Это может показаться странным, но по сути не сильно отличается от метода, у которого получатель — канал, отправляющий данные.

Чтобы превратить `ArgServer` в HTTP-сервер, сначала изменим её сигнатуру:

```go
// Сервер аргументов.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
```

Теперь `ArgServer` имеет ту же сигнатуру, что и `HandlerFunc`, поэтому её можно привести к этому типу и использовать его методы, аналогично тому, как мы приводили `Sequence` к `IntSlice` для использования метода `IntSlice.Sort`.  
Настройка сервера предельно лаконична:

```go
http.Handle("/args", http.HandlerFunc(ArgServer))
```

Когда кто-то посещает страницу `/args`, обработчик, привязанный к этому маршруту, представляет собой значение `ArgServer` типа `HandlerFunc`.  
HTTP-сервер вызывает метод `ServeHTTP` этого типа, передавая `ArgServer` в качестве получателя, который затем вызывает `ArgServer` (через `f(w, req)` внутри `HandlerFunc.ServeHTTP`), что приводит к выводу аргументов.

В этом разделе мы создали HTTP-сервер, используя структуру, целое число, канал и функцию — всё потому, что интерфейсы в Go представляют собой просто наборы методов, которые можно определять для (почти) любого типа.

## Пустой идентификатор

Мы уже несколько раз упоминали пустой идентификатор в контексте  
[циклов `for range`](#for) и [отображений (maps)](#maps).  
Пустому идентификатору можно присвоить или объявить любое значение любого типа,  
и это значение будет просто отброшено без последствий.  

Это немного похоже на запись в файл Unix `/dev/null`:  
он представляет собой "значение только для записи",  
которое используется как заполнитель там,  
где нужна переменная, но фактическое значение не имеет значения.  

Однако область его применения шире, чем мы видели ранее.

### Пустой идентификатор в множественном присваивании

Использование пустого идентификатора в цикле `for range` —  
это частный случай более общей ситуации: множественного присваивания.  

Если в присваивании требуется несколько значений слева,  
но одно из них не будет использоваться программой,  
то использование пустого идентификатора на левой стороне  
избегает создания ненужной переменной и четко указывает,  
что значение просто отбрасывается.  

Например, если вызывается функция, возвращающая значение и ошибку,  
но нас интересует только ошибка,  
пустой идентификатор поможет избавиться от ненужного значения:

```go
if _, err := os.Stat(path); os.IsNotExist(err) {
    fmt.Printf("%s does not exist\n", path)
}
```

Иногда можно встретить код, в котором значение ошибки  
просто отбрасывается, чтобы проигнорировать саму ошибку.  
Это ужасная практика!  
Всегда проверяйте возвращаемые ошибки — они даны не просто так.

```go
// Плохо! Этот код упадёт, если path не существует.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
```

### Неиспользуемые пакеты и переменные

В Go является ошибкой импортировать пакет или объявлять переменную,  
не используя их.  

Неиспользуемые пакеты увеличивают размер программы и замедляют компиляцию,  
а переменная, которая была инициализирована, но не используется,  
как минимум означает потерянные вычисления и, возможно,  
указывает на более серьезную проблему в коде.  

Однако в процессе активной разработки программы  
неиспользуемые импорты и переменные часто появляются,  
и бывает неудобно их удалять,  
чтобы компиляция прошла успешно,  
если они вскоре могут снова понадобиться.  

Пустой идентификатор решает эту проблему.

Этот недописанный код содержит два неиспользуемых импорта  
(`fmt` и `io`) и неиспользуемую переменную (`fd`),  
поэтому он не скомпилируется.  
Но хотелось бы проверить, правильна ли написанная часть программы.

В приведённом коде есть неиспользуемые импортированные пакеты (`fmt` и `io`) и неиспользуемая переменная `fd`, что приведёт к ошибке компиляции в Go.  

### Исправленный код с использованием пустого идентификатора

Если вам нужно временно подавить ошибки о неиспользуемых переменных и импортированных пакетах, можно сделать так:

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: использовать fd.
}
```

Чтобы подавить ошибки о неиспользуемых импортированных пакетах,  
можно обратиться к какому-либо символу из этих пакетов через пустой идентификатор.  
Точно так же можно присвоить неиспользуемую переменную `fd` пустому идентификатору,  
чтобы избежать ошибки о неиспользуемой переменной.  

Этот вариант программы уже компилируется.

```go
package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf // For debugging; delete when done.
var _ io.Reader    // For debugging; delete when done.

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    // TODO: использовать fd.
    _ = fd
}
```

По соглашению, глобальные объявления, используемые для подавления ошибок о неиспользуемых пакетах, должны следовать сразу после блока `import` и сопровождаться комментариями. Это упрощает их поиск и служит напоминанием  о необходимости очистки кода в будущем.

### Импорт ради побочного эффекта

Неиспользуемый импорт, например `fmt` или `io`, как в предыдущем примере, в конечном итоге должен быть либо использован, либо удалён: пустые присваивания указывают, что код находится в процессе разработки. Однако иногда бывает полезно импортировать пакет только ради его побочных эффектов, без явного использования.

Например, во время выполнения своей функции `init` пакет [`net/http/pprof`](https://pkg.go.dev/net/http/pprof) регистрирует HTTP-обработчики, которые предоставляют отладочную информацию. Хотя у него есть экспортируемый API, большинству клиентов требуется только регистрация обработчиков, а доступ к данным осуществляется через веб-страницу.

Чтобы импортировать пакет только ради его побочных эффектов, его имя заменяют на пустой идентификатор:

```go
import _ "net/http/pprof"
```

Такой способ импорта чётко указывает, что пакет импортируется только ради его побочных эффектов, поскольку его нельзя использовать каким-либо другим способом: в этом файле у него нет имени. (Если бы имя было, но оно не использовалось, компилятор отклонил бы программу.)

### Проверка реализации интерфейсов

Как мы видели в обсуждении [интерфейсов](#interfaces_and_types), типу не нужно явно объявлять, что он реализует интерфейс. Вместо этого тип реализует интерфейс просто за счёт реализации его методов.

На практике большинство преобразований интерфейсов являются статическими и, следовательно, проверяются во время компиляции. Например, передача `*os.File` в функцию, ожидающую `io.Reader`, не скомпилируется, если `*os.File` не реализует интерфейс `io.Reader`.

Однако некоторые проверки интерфейсов выполняются во время выполнения. Один из таких случаев встречается в пакете [`encoding/json`](https://pkg.go.dev/encoding/json), который определяет интерфейс [`Marshaler`](https://pkg.go.dev/encoding/json#Marshaler). Когда JSON-энкодер получает значение, реализующее этот интерфейс, он вызывает метод маршалинга этого значения для преобразования в JSON вместо стандартного преобразования.

Энкодер проверяет это свойство во время выполнения с помощью [утверждения типа](#interface_conversions), например:

```go
m, ok := val.(json.Marshaler)
```

Если требуется только проверить, реализует ли тип интерфейс, но не использовать его непосредственно (например, как часть проверки на ошибку), можно проигнорировать значение, полученное при утверждении типа, используя пустой идентификатор:

```go
if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("значение %v типа %T реализует json.Marshaler\n", val, val)
}
```

Один из случаев, когда это используется, — необходимость гарантировать в пределах пакета, реализующего тип, что он действительно удовлетворяет интерфейсу.

Если тип (например, [`json.RawMessage`](https://pkg.go.dev/encoding/json#RawMessage)) требует собственного представления JSON, он должен реализовывать `json.Marshaler`, но в коде могут отсутствовать статические преобразования, которые позволили бы компилятору проверить это автоматически. Если тип случайно не удовлетворяет интерфейсу, JSON-энкодер всё равно будет работать, но не будет использовать кастомную реализацию.

Чтобы гарантировать корректность реализации, в пакете можно использовать глобальное объявление с пустым идентификатором:

```go
var _ json.Marshaler = (*RawMessage)(nil)
```

В этом объявлении присваивание, связанное с преобразованием `*RawMessage` в `Marshaler`, требует, чтобы `*RawMessage` реализовывал `Marshaler`, и эта проверка будет выполняться во время компиляции. Если интерфейс `json.Marshaler` изменится, этот пакет перестанет компилироваться, что послужит сигналом о необходимости обновления кода.

Использование пустого идентификатора в таком объявлении показывает, что оно существует только для проверки типа, а не для создания переменной. Однако не стоит применять этот приём для всех типов, удовлетворяющих интерфейсу. По общему соглашению такие объявления используются только в тех случаях, когда в коде нет других статических преобразований, позволяющих компилятору выполнить эту проверку — что случается довольно редко.

## Встраивание (Embedding)

Go не предоставляет типичное, управляемое типами понятие наследования, но он позволяет *«заимствовать»* части реализации с помощью **встраивания** типов в `struct` или `interface`.

### Встраивание интерфейсов

Встраивание интерфейсов в Go очень простое. Мы уже упоминали интерфейсы `io.Reader` и `io.Writer`. Вот их определения:

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

Пакет `io` также экспортирует несколько других интерфейсов, которые определяют объекты, способные реализовать сразу несколько таких методов. Например, существует интерфейс `io.ReadWriter`, содержащий методы `Read` и `Write`. Мы могли бы явно перечислить эти два метода, но удобнее и нагляднее создать новый интерфейс, встроив оба интерфейса следующим образом:

```go
// ReadWriter — интерфейс, объединяющий интерфейсы Reader и Writer.
type ReadWriter interface {
    Reader
    Writer
}
```

Этот код означает именно то, что кажется: `ReadWriter` может делать всё, что делает `Reader`, *и* всё, что делает `Writer`. Это объединение встроенных интерфейсов. Обратите внимание, что только интерфейсы могут быть встроены в другие интерфейсы.

### Встраивание в структуры

Та же базовая идея применима и к структурам, но с более далеко идущими последствиями. В пакете `bufio` есть две структуры — `bufio.Reader` и `bufio.Writer`, каждая из которых, естественно, реализует соответствующие интерфейсы из пакета `io`.

Пакет `bufio` также предоставляет буферизированный `Reader/Writer`, который объединяет `Reader` и `Writer` в одну структуру с помощью встраивания. Для этого он просто указывает типы внутри структуры без присвоения им имен полей:

```go
// ReadWriter хранит указатели на Reader и Writer.
// Он реализует интерфейс io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
```

Встроенные элементы являются указателями на структуры и, конечно, должны быть инициализированы перед использованием. Структура `ReadWriter` могла бы быть записана так:

```go
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
```

Но тогда, чтобы продвигать методы этих полей и соответствовать интерфейсам `io`, нам пришлось бы вручную добавлять методы-обертки:

```go
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
```

Однако, встраивая структуры напрямую, мы избавляемся от этой рутины. Методы встроенных типов автоматически «прикрепляются» к внешнему типу, благодаря чему `bufio.ReadWriter` не только получает методы `bufio.Reader` и `bufio.Writer`, но и удовлетворяет сразу трем интерфейсам:  

- `io.Reader`,  
- `io.Writer`,  
- `io.ReadWriter`.

### Различия между встраиванием и наследованием

Есть важное отличие между встраиванием и наследованием. Когда мы встраиваем тип, его методы становятся методами внешнего типа, *но* при вызове метод получает в качестве получателя (receiver) не внешний тип, а вложенный.

В нашем примере, когда вызывается метод `Read` у `bufio.ReadWriter`, он работает точно так же, как если бы мы вручную написали метод-обертку выше:  
получателем является поле `reader` внутри `ReadWriter`, а не сам `ReadWriter`.

### Упрощение кода с помощью встраивания

Встраивание также может быть удобным инструментом для упрощения кода. В этом примере встроенное поле используется наряду с обычным именованным полем:

```go
type Job struct {
    Command string
    *log.Logger
}
```

Теперь `Job` обладает методами `Print`, `Printf`, `Println` и другими методами `*log.Logger`. Конечно, мы могли бы явно задать поле для `Logger`, но в этом нет необходимости. После инициализации можно просто записывать логи в `Job`:

```go
job.Println("starting now...")
```

Так как `Logger` — это обычное поле в `Job`, его можно инициализировать в конструкторе:

```go
func NewJob(command string, logger *log.Logger) *Job {
    return &Job{command, logger}
}
```

Или с помощью составного литерала:

```go
job := &Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
```

Если нам нужно явно обратиться к встроенному полю, можно использовать имя типа (без указания пакета) в качестве имени поля. Например, если у нас есть переменная `job` типа `Job`, доступ к `*log.Logger` осуществляется через `job.Logger`. Это полезно, если мы хотим переопределить методы `Logger`:

```go
func (job *Job) Printf(format string, args ...interface{}) {
    job.Logger.Printf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
```

### Конфликты имен при встраивании

Встраивание типов может привести к конфликтам имен, но правила их разрешения просты:

1. Поле или метод `X` скрывает любое другое поле или метод `X`, находящееся глубже в иерархии типа.  
   Например, если `log.Logger` содержал бы поле или метод `Command`, то в `Job` приоритет имело бы поле `Command` структуры `Job`.

2. Если одно и то же имя встречается на одном уровне вложенности дважды, это обычно является ошибкой. Например, в `Job` нельзя было бы одновременно иметь встроенное `log.Logger` и отдельное поле или метод `Logger`.

Однако, если дублирующееся имя нигде не используется в коде, кроме определения типа, то это допустимо. Такое правило дает защиту от случайных конфликтов при изменении типов, встроенных из других пакетов:  
если два встроенных типа добавляют одинаковое поле, но оно нигде не используется, компилятор не выдаст ошибку.

Таким образом, встраивание в Go — это мощный инструмент, который позволяет повторно использовать код, избегая сложностей наследования, и делает код более лаконичным и выразительным. 🚀

## Параллельность (Concurrency)

### Обмен через коммуникацию (Share by communicating)

Параллельное программирование — обширная тема, и здесь будет рассмотрено лишь несколько особенностей, характерных для Go.

Во многих средах программирование с использованием параллельных вычислений затруднено из-за сложностей, связанных с корректным доступом к разделяемым переменным. Go предлагает иной подход: вместо того чтобы несколько потоков исполнения совместно использовали одни и те же значения, эти значения передаются через каналы и фактически никогда не используются одновременно разными потоками. В каждый момент времени только одна горутина имеет доступ к значению. Это исключает гонки данных на уровне дизайна.

Чтобы поддержать такое мышление, мы свели его к краткому принципу:

> Не передавайте данные через разделяемую память;  
> вместо этого передавайте память через коммуникацию.

Этот подход можно довести до абсурда. Например, для подсчёта ссылок (reference counting) может быть целесообразнее использовать мьютекс вокруг целочисленной переменной. Однако в целом управление доступом через каналы делает код более понятным и корректным.

Один из способов представить эту модель — подумать о типичной однопоточной программе, выполняемой на одном процессоре. Такая программа не нуждается в механизмах синхронизации. Теперь запустим ещё один такой же экземпляр программы — ему также не требуется синхронизация. Если теперь эти два экземпляра начнут взаимодействовать, но при этом сама коммуникация будет механизмом синхронизации, то и дополнительные примитивы синхронизации останутся ненужными. Примером этого подхода могут служить конвейеры (pipelines) в Unix. Хотя модель параллельности в Go основана на концепции *Communicating Sequential Processes* (CSP), предложенной Хоаром, её также можно рассматривать как типобезопасное обобщение механизмов Unix-пайпов.

### Горутины (Goroutines)

Они называются *горутины* (goroutines), потому что стандартные термины — *потоки* (threads), *корутины* (coroutines), *процессы* (processes) и так далее — несут неверные ассоциации. Горутина имеет простую модель: это функция, выполняемая параллельно с другими горутинами в одном адресном пространстве. Она лёгкая, требуя лишь выделения памяти под стек.

Причём начальный размер стека небольшой, что делает горутины дешёвыми, но он может динамически расти за счёт выделения (и освобождения) памяти в куче по мере необходимости.

Горутины мультиплексируются на несколько потоков операционной системы, поэтому если одна из них блокируется (например, ожидает ввода-вывода), другие продолжают выполняться. Этот дизайн скрывает множество сложностей, связанных с созданием и управлением потоками.

Чтобы запустить функцию в отдельной горутине, перед её вызовом добавьте ключевое слово `go`. Когда выполнение функции завершится, горутина завершится автоматически и молча. Это похоже на использование `&` в командной строке Unix для запуска команды в фоновом режиме.

```go
go list.Sort()  // Выполнить list.Sort параллельно, не ожидая завершения.
```

Функции-литералы могут быть удобны при создании горутин:

```go
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Обратите внимание на скобки — функцию нужно вызвать.
}
```

В Go функции-литералы являются *замыканиями* (closures): реализация гарантирует, что переменные, на которые ссылается функция, останутся доступными, пока они нужны.

Однако приведённые примеры не очень практичны, так как функции не могут сообщить о завершении своей работы. Для этого нам понадобятся каналы.

### Каналы

Как и мапы (maps), каналы создаются с помощью `make`, а полученное значение действует как ссылка на базовую структуру данных. Если передан необязательный целочисленный параметр, он устанавливает размер буфера для канала. По умолчанию его значение равно нулю, что делает канал неблокирующим (unbuffered) или синхронным.

```go
ci := make(chan int)            // неблокирующий канал для целых чисел
cj := make(chan int, 0)         // неблокирующий канал для целых чисел
cs := make(chan *os.File, 100)  // буферизированный канал для указателей на файлы
```

Небуферизированные каналы объединяют передачу данных (обмен значениями) с синхронизацией, гарантируя, что два вычисления (горутины) находятся в известном состоянии.

Существует множество удобных способов использования каналов. Вот один из них. В предыдущем разделе мы запускали сортировку в фоновом режиме. Канал позволяет горутине, запускающей сортировку, дождаться её завершения.

```go
c := make(chan int)  // Создаём канал.
// Запускаем сортировку в горутине; по завершении посылаем сигнал в канал.
go func() {
    list.Sort()
    c <- 1  // Отправляем сигнал; значение не имеет значения.
}()
doSomethingForAWhile()
<-c   // Ожидаем завершения сортировки; игнорируем отправленное значение.
```

Получатели всегда блокируются, пока не появятся данные для получения.  
Если канал неблокирующий, отправитель блокируется, пока получатель не заберёт значение.  
Если канал буферизирован, отправитель блокируется только до момента копирования значения в буфер; если буфер заполнен, он ждёт, пока какое-либо значение не будет получено.

Буферизированный канал можно использовать как семафор, например, для ограничения пропускной способности. В этом примере входящие запросы передаются в `handle`, который отправляет значение в канал, обрабатывает запрос, а затем получает значение из канала, подготавливая «семафор» для следующего потребителя.  
Ёмкость буфера канала ограничивает количество одновременных вызовов `process`.

```go
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1    // Ожидаем освобождения активной очереди.
    process(r)  // Может занять продолжительное время.
    <-sem       // Завершено; разрешаем следующий запрос.
}

func Serve(queue chan *Request) {
    for {
        req := <-queue
        go handle(req)  // Не ждём завершения handle.
    }
}
```

Когда `MaxOutstanding` обработчиков выполняют `process`, новые запросы блокируются при попытке отправки в заполненный буфер канала. Это продолжается до тех пор, пока один из обработчиков не завершит работу и не освободит место в буфере.

Однако у этого дизайна есть проблема: `Serve` создаёт новую горутину для каждого входящего запроса, даже если одновременно могут выполняться только `MaxOutstanding` обработчиков. Это может привести к неограниченному потреблению ресурсов, если запросы поступают слишком быстро.  
Мы можем устранить этот недостаток, изменив `Serve`, чтобы контролировать создание горутин:

```go
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func() {
            process(req)
            <-sem
        }()
    }
}
```

> (Обратите внимание, что в версиях Go до 1.22 в этом коде есть ошибка: переменная цикла используется всеми горутинами совместно. Подробнее см. на [Go wiki](https://golang.org/wiki/LoopvarExperiment).)

Другой подход к управлению ресурсами – запустить фиксированное количество горутин `handle`, которые все читают из канала запросов.  
Количество горутин ограничивает число одновременных вызовов `process`.  
Эта функция `Serve` также принимает канал, через который ей будет сообщено о завершении работы; после запуска горутин она блокируется, ожидая сигнала выхода.

```go
func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Запускаем обработчики
    for i := 0; i < MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    <-quit  // Ожидаем команды завершения.
}
```

### Каналы каналов

Одним из важнейших свойств Go является то, что канал — это полноценное значение, которое можно выделять в памяти и передавать, как и любой другой объект. Это свойство часто используется для безопасного, параллельного демультиплексирования.

В примере из предыдущего раздела функция `handle` была идеализированным обработчиком запроса, но мы не определили тип, который она обрабатывала. Если этот тип включает канал для ответа, каждый клиент может предоставить свой собственный путь для получения результата. Вот схематичное определение типа `Request`:

```go
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
```

Клиент передаёт функцию и её аргументы, а также канал внутри объекта запроса, по которому будет получен ответ.

```go
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// Отправляем запрос
clientRequests <- request
// Ожидаем ответа
fmt.Printf("answer: %d\n", <-request.resultChan)
```

На стороне сервера изменяется только обработчик:

```go
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```

Очевидно, что для полноценного использования этой идеи потребуется ещё многое реализовать, но этот код уже представляет собой каркас для ограниченной по скорости, параллельной, неблокирующей RPC-системы — и при этом нигде нет мьютексов.

### Параллелизация

Другая сфера применения этих идей — параллелизация вычислений на нескольких ядрах процессора. Если вычисление можно разбить на отдельные независимые части, его можно выполнить параллельно, используя канал для сигнализации о завершении каждой части.

Допустим, у нас есть вычислительная операция, выполняемая над вектором элементов, и значение этой операции для каждого элемента не зависит от остальных, как в этом упрощённом примере:

```go
type Vector []float64

// Применяет операцию к v[i], v[i+1] ... до v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1 // сигнализируем о завершении этого фрагмента
}
```

Мы запускаем обработку независимых фрагментов в цикле, по одному на каждое ядро CPU. Они могут завершаться в любом порядке — это не имеет значения, так как мы просто считаем сигналы завершения, извлекая данные из канала после запуска всех горутин.

```go
const numCPU = 4 // количество ядер CPU

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)  // Буферизация опциональна, но разумна.
    for i := 0; i < numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    // Ожидаем завершения всех задач.
    for i := 0; i < numCPU; i++ {
        <-c
    }
    // Все готово.
}
```

Вместо того чтобы задавать `numCPU` как константу, можно запросить у рантайма актуальное значение. Функция [`runtime.NumCPU`](https://pkg.go.dev/runtime#NumCPU) возвращает количество аппаратных ядер процессора на машине:

```go
var numCPU = runtime.NumCPU()
```

Также есть функция [`runtime.GOMAXPROCS`](https://pkg.go.dev/runtime#GOMAXPROCS), которая определяет (или изменяет) количество ядер, которые могут одновременно выполнять Go-программу. По умолчанию оно равно `runtime.NumCPU`, но его можно изменить через переменную окружения с тем же именем или вызовом этой функции с положительным числом. Если передать `0`, то функция просто возвращает текущее значение.

Таким образом, если мы хотим учитывать настройки пользователя, следует использовать:

```go
var numCPU = runtime.GOMAXPROCS(0)
```

Важно не путать понятия **конкурентности** (разделение программы на независимые выполняемые компоненты) и **параллелизма** (одновременное выполнение вычислений для повышения эффективности на нескольких процессорах). Хотя механизмы конкурентности в Go позволяют легко структурировать некоторые задачи в виде параллельных вычислений, сам язык Go является **конкурентным, а не параллельным**, и не все задачи по параллелизации подходят для его модели.

Для обсуждения этого различия можно ознакомиться с докладом, упомянутым в [этом блоге](https://blog.golang.org/concurrency-is-not-parallelism).

### Протекающий буфер (Leaky Buffer)

Инструменты конкурентного программирования могут облегчить выражение даже неконкурентных идей. Вот пример, абстрагированный из пакета RPC.  

Горутина клиента выполняет цикл, получая данные из некоторого источника, возможно, из сети. Чтобы избежать постоянного выделения и освобождения буферов, она поддерживает список свободных буферов, представленный буферизированным каналом. Если канал пуст, создаётся новый буфер.  
Когда буфер сообщения готов, он отправляется серверу через `serverChan`.  

```go
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Захватываем буфер, если он доступен; создаём новый, если нет.
        select {
        case b = <-freeList:
            // Получили буфер; ничего больше делать не нужно.
        default:
            // Нет свободных — выделяем новый.
            b = new(Buffer)
        }
        load(b)              // Читаем следующее сообщение из сети.
        serverChan <- b      // Отправляем серверу.
    }
}
```

Цикл сервера принимает каждое сообщение от клиента, обрабатывает его и возвращает буфер в список свободных.  

```go
func server() {
    for {
        b := <-serverChan    // Ожидаем работу.
        process(b)
        // Повторно используем буфер, если есть место.
        select {
        case freeList <- b:
            // Буфер добавлен в список свободных; больше ничего делать не нужно.
        default:
            // Список свободных полон — просто продолжаем работу.
        }
    }
}
```

Клиент пытается получить буфер из `freeList`; если свободного буфера нет, создаётся новый.  
Сервер отправляет `b` обратно в `freeList`, если там есть место. Если же список свободных заполнен, буфер просто «падает на пол» и будет собран **garbage collector**-ом.  

(Ключевые слова `default` в операторах `select` выполняются, когда ни один другой вариант недоступен, то есть `select` никогда не блокируется.)  

Эта реализация создаёт протекающий список свободных буферов всего за несколько строк кода, используя буферизированный канал и **garbage collector** для управления памятью.

### Ошибки

Библиотечные функции часто должны возвращать какое-либо указание на ошибку вызывающему коду. Как упоминалось ранее, многозначный возврат в Go делает возможным одновременный возврат как основного значения, так и детального описания ошибки. Использование этой возможности для предоставления подробной информации об ошибке является хорошим стилем.

Например, как мы увидим, `os.Open` при сбое не просто возвращает `nil`-указатель, но также возвращает значение ошибки, описывающее, что пошло не так.

По соглашению ошибки в Go имеют тип `error` — это встроенный интерфейс:

```go
type error interface {
    Error() string
}
```

Разработчик библиотеки может реализовать этот интерфейс с более сложной моделью внутри, что позволяет не только видеть ошибку, но и предоставлять дополнительный контекст. Как уже упоминалось, помимо обычного значения `*os.File`, функция `os.Open` также возвращает значение ошибки. Если файл успешно открыт, ошибка будет `nil`, но в случае проблемы она будет содержать `os.PathError`:

```go
// PathError хранит ошибку, а также операцию и путь к файлу, вызвавшие её.
type PathError struct {
    Op   string  // "open", "unlink" и т. д.
    Path string  // Связанный файл.
    Err  error   // Ошибка, возвращённая системным вызовом.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

Метод `Error` структуры `PathError` генерирует строку вида:

```text
open /etc/passwx: no such file or directory
```

Такая ошибка, включающая имя проблемного файла, операцию и ошибку операционной системы, полезна даже при выводе в месте, далёком от вызова, вызвавшего её. Она намного информативнее, чем просто "no such file or directory".

Когда это возможно, строки ошибок должны содержать информацию о своём происхождении, например, в виде префикса с названием операции или пакета, вызвавшего ошибку. Например, в пакете `image` строковое представление ошибки декодирования из-за неизвестного формата имеет вид `"image: unknown format"`.

Вызывающий код, которому важны конкретные детали ошибки, может использовать переключатель типов (`type switch`) или приведение типа (`type assertion`), чтобы определить конкретный тип ошибки и извлечь дополнительные сведения. Для `PathError` это может включать проверку поля `Err` на предмет исправимых ошибок:

```go
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Освободить место.
        continue
    }
    return
}
```

Второй оператор `if` здесь — это ещё одно [приведение типа](#interface_conversions). Если приведение не удалось, `ok` будет `false`, а `e` — `nil`. Если же оно успешно, `ok` будет `true`, что означает, что ошибка имеет тип `*os.PathError`, и теперь мы можем извлечь из неё дополнительную информацию.

### Паника (Panic)

Обычный способ сообщить вызывающему коду об ошибке — вернуть значение `error` в качестве дополнительного возвращаемого параметра. Хорошо известным примером этого является метод `Read`, который возвращает количество прочитанных байтов и `error`. Но что делать, если ошибка невосстановима? Иногда программа просто не может продолжать выполнение.

Для этой цели существует встроенная функция `panic`, которая, по сути, создает ошибку времени выполнения, останавливающую программу (но см. следующий раздел). Функция принимает единственный аргумент произвольного типа — часто это строка, — который будет напечатан перед завершением программы. Это также способ указать, что произошло нечто невозможное, например выход из бесконечного цикла.

```go
// Игрушечная реализация вычисления кубического корня с использованием метода Ньютона.
func CubeRoot(x float64) float64 {
    z := x / 3  // Произвольное начальное значение
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z - x) / (3 * z * z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // Миллион итераций не привел к сходимости; что-то пошло не так.
    panic(fmt.Sprintf("CubeRoot(%g) не сошёлся", x))
}
```

Этот пример носит демонстрационный характер, но в реальных библиотечных функциях следует избегать использования `panic`. Если проблему можно скрыть или обойти, всегда лучше позволить программе продолжить работу, чем аварийно завершать её выполнение. Однако возможным исключением может быть этап инициализации: если библиотека действительно не может корректно настроиться, возможно, оправдано вызвать `panic`.

```go
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("переменная $USER не задана")
    }
}
```

### Восстановление (Recover)

Когда вызывается `panic`, включая неявные случаи, такие как ошибки времени выполнения (например, выход за границы среза или неудачное приведение типа), выполнение текущей функции немедленно прекращается, и начинается разворачивание (unwinding) стека горутины. При этом выполняются все отложенные (`defer`) функции. Если разворачивание достигает вершины стека горутины, программа завершается. Однако можно использовать встроенную функцию `recover`, чтобы перехватить панику и продолжить выполнение программы.

Вызов `recover` останавливает разворачивание стека и возвращает аргумент, переданный в `panic`. Поскольку во время разворачивания выполняются только отложенные функции, `recover` полезен только внутри таких функций.

Один из вариантов использования `recover` — перехват паники в горутине сервера, чтобы не останавливать выполнение других горутин.

```go
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

В этом примере, если `do(work)` вызывает панику, ошибка будет зафиксирована в журнале, а горутина завершится корректно, не влияя на остальные. В отложенной функции не нужно делать ничего, кроме вызова `recover`, так как он полностью обрабатывает ситуацию.

Поскольку `recover` всегда возвращает `nil`, если его вызывают не из отложенной функции, другие отложенные вызовы (например, в сторонних библиотеках) могут использовать `panic` и `recover` без риска некорректного поведения. Например, в `safelyDo` можно вызывать функции логирования до `recover`, и они будут выполняться без влияния состояния паники.

С помощью этого шаблона функция `do` (и все её подфункции) может выходить из сложных ситуаций, вызывая `panic`. Это упрощает обработку ошибок в сложных программах. Рассмотрим упрощённую версию пакета `regexp`, который сообщает об ошибках парсинга, вызывая `panic` с локальным типом ошибки. Вот определение `Error`, метода `error` и функции `Compile`.

```go
// Error — это тип ошибки парсинга; он реализует интерфейс error.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error — метод *Regexp, который сообщает об ошибках парсинга,
// вызывая панику с типом Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile возвращает разобранное представление регулярного выражения.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse вызовет панику в случае ошибки парсинга.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Обнуляем возвращаемое значение.
            err = e.(Error) // Повторно вызовет панику, если это не ошибка парсинга.
        }
    }()
    return regexp.doParse(str), nil
}
```

Если `doParse` вызывает панику, блок `recover` устанавливает `nil` в возвращаемое значение `regexp` (так как отложенные функции могут изменять именованные возвращаемые значения). Затем выполняется приведение типа ошибки к `Error`. Если приведение типа не удаётся, происходит ошибка времени выполнения, и разворачивание стека продолжается, как если бы `recover` не было вызвано. Это гарантирует, что неожиданные ошибки (например, выход за границы массива) не будут скрыты механизмом `panic` и `recover`.

После реализации обработки ошибок метод `error` (так как это метод типа, он может и даже должен называться так же, как встроенный тип `error`) позволяет легко сообщать об ошибках парсинга, не заботясь о ручном сворачивании стека парсинга:

```go
if pos == 0 {
    re.error("'*' недопустим в начале выражения")
}
```

Хотя этот шаблон полезен, его следует применять только внутри пакета. Функция `Compile` преобразует внутренние вызовы `panic` в значения `error`, не передавая клиентскому коду сами паники. Это хороший принцип, которого стоит придерживаться.

Кстати, повторная паника в блоке `recover` изменяет передаваемое значение, если возникает другая ошибка. Однако в отчёте о сбое будут отображаться как исходная, так и новая ошибки, поэтому корень проблемы останется видимым. Такой подход обычно достаточен (ведь это всё равно сбой), но если нужно показать только исходную ошибку, можно написать код, фильтрующий неожиданные проблемы и вызывающий панику заново с первоначальной ошибкой. Оставляем это упражнение читателю.

### Веб-сервер

Давайте закончим полноценной программой на Go — веб-сервером.  
Этот сервер фактически представляет собой своего рода веб-пересылатель.  
Google предоставляет сервис на `chart.apis.google.com`,  
который автоматически форматирует данные в диаграммы и графики.  
Однако использовать его в интерактивном режиме довольно неудобно,  
потому что данные необходимо передавать в URL в виде запроса.  

Программа, представленная здесь, предлагает более удобный интерфейс для одного типа данных:  
введя короткий фрагмент текста, сервер Google создаст QR-код —  
матрицу из ячеек, кодирующих этот текст.  
Изображение можно считать камерой мобильного телефона,  
а затем интерпретировать, например, как URL,  
что избавляет от необходимости вручную вводить ссылку на маленькой клавиатуре телефона.  

### Полный код программы  

Вот полная программа. После неё следует объяснение.  

```go
package main

import (
    "flag"         // Для обработки аргументов командной строки
    "html/template" // Для работы с HTML-шаблонами
    "log"          // Для логирования ошибок
    "net/http"     // Для создания веб-сервера
)

// Определяем адрес сервера с возможностью изменения через аргументы командной строки
var addr = flag.String("addr", ":1718", "http service address")

// Создаём HTML-шаблон, который будет использоваться для генерации страницы
var templ = template.Must(template.New("qr").Parse(templateStr))

func main() {
    flag.Parse() // Разбираем аргументы командной строки (если передан другой порт)

    // Регистрируем обработчик для корневого URL "/"
    http.Handle("/", http.HandlerFunc(QR))

    // Запускаем HTTP-сервер на указанном адресе
    err := http.ListenAndServe(*addr, nil)
    if err != nil {
        log.Fatal("ListenAndServe:", err) // Если сервер не удалось запустить, логируем ошибку и завершаем программу
    }
}

// QR обрабатывает HTTP-запросы, рендерит HTML-шаблон и отправляет его клиенту
func QR(w http.ResponseWriter, req *http.Request) {
    // Получаем значение параметра "s" из GET-запроса и вставляем его в шаблон
    templ.Execute(w, req.FormValue("s"))
}

// HTML-шаблон страницы
const templateStr = `
<html>
<head>
<title>QR Link Generator</title>
</head>
<body>
{{if .}} <!-- Если передан текст, отображаем QR-код -->
<img src="http://chart.apis.google.com/chart?chs=300x300&cht=qr&choe=UTF-8&chl={{.}}" />
<br>
{{.}} <!-- Отображаем введённый текст ниже QR-кода -->
<br>
<br>
{{end}}
<form action="/" name=f method="GET"> <!-- Форма для ввода текста -->
    <input maxLength=1024 size=70 name=s value="" title="Text to QR Encode"> <!-- Поле ввода -->
    <input type=submit value="Show QR" name=qr> <!-- Кнопка отправки формы -->
</form>
</body>
</html>
`
```

### Разбор программы  

Фрагменты кода до функции `main` должны быть понятны.  
Один флаг задаёт HTTP-порт по умолчанию для нашего сервера.  
Шаблонная переменная `templ` — вот где начинается самое интересное.  
Она содержит HTML-шаблон, который будет использоваться сервером для отображения страницы.  
Подробнее об этом чуть позже.  

Функция `main` парсит флаги и, используя описанный выше механизм,  
связывает функцию `QR` с корневым маршрутом сервера.  
Затем вызывается `http.ListenAndServe`, чтобы запустить сервер,  
который будет работать в фоновом режиме.  

Функция `QR` принимает HTTP-запрос, содержащий данные формы,  
и передаёт эти данные в шаблонную функцию `templ.Execute`,  
используя значение параметра формы `s`.  

### Еще раз

- Запускает веб-сервер на `http://localhost:1718`.
- Ожидает GET-запросы с параметром `s` (текст для кодирования).
- Генерирует HTML-страницу с QR-кодом (использует API Google Charts).
- Позволяет ввести текст и получить QR-код.

### Как запустить?

1. Компилируем и запускаем сервер:

   ```sh
   go run main.go
   ```

2. Открываем в браузере:

   ```
   http://localhost:1718
   ```

3. Вводим текст, нажимаем "Show QR", получаем QR-код.

### Работа с HTML-шаблонами  

Пакет `html/template` — мощный инструмент.  
В данной программе мы используем лишь небольшую часть его возможностей.  
По сути, он позволяет динамически модифицировать HTML-код,  
заменяя части текста элементами, полученными из переданных в `templ.Execute` данных.  
В данном случае передаётся значение формы.  

Внутри шаблонного текста (`templateStr`)  
двойные фигурные скобки обозначают команды шаблона.  
Фрагмент `{{"{{if .}}"}}` … `{{"{{end}}"}}`  
выполняется только если текущий элемент данных (обозначаемый точкой `.`)  
не является пустым.  
То есть, если строка пустая, этот фрагмент шаблона не отображается.  

Два вхождения `{{"{{.}}"}}` указывают на вывод данных,  
переданных в шаблон — в данном случае запроса от пользователя.  
Пакет `html/template` автоматически экранирует HTML,  
чтобы текст был безопасен для отображения в браузере.  

Остальная часть строки шаблона — это просто HTML-код,  
который загружается при открытии страницы.  
Если вам требуется более подробное объяснение,  
обратитесь к [документации](https://pkg.go.dev/html/template) по пакету `template`.  

### Итог  

Вот и всё: полезный веб-сервер, состоящий всего из нескольких строк кода  
и данных в формате HTML-шаблона.  
Go достаточно мощен, чтобы позволить реализовать такую функциональность  
всего несколькими строками.
