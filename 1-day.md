**День 1: Глубокое погружение в конкуррентность Go**

**Темы:** Горутины, каналы, мьютексы, примитивы синхронизации.

**Теория:** Разобраться, как Go реализует конкурентность через горутины и каналы. Освежите понимание модели CSP (communicating sequential processes) и принципа «Do not communicate by sharing memory, share memory by communicating». Узнайте, почему горутины настолько легковесны и как Go умеет запускать тысячи параллельных задач без большого оверхеда ([Многопоточность и параллелизм в Go: Goroutines и каналы / Хабр](https://habr.com/ru/companies/mvideo/articles/778248/#:~:text=%D0%AF%D0%B7%D1%8B%D0%BA%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20Go%2C%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%81,%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20Goroutines%20%D0%B8%20%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D1%8B)). Разберите, какие примитивы синхронизации есть в стандартной библиотеке (например, `sync.Mutex`, `sync.RWMutex`, `sync.WaitGroup`, каналы) и в каких случаях их применять.

**Практика:** Напишите простое приложение с использованием нескольких горутин и каналов (например, конкурентно вычисляйте сумму элементов массива частями и собирайте результат через канал). Реализуйте задачу “producer-consumer” с буферизованным каналом. Попрактикуйтесь в использовании мьютексов для защиты общих данных (например, общий счётчик, инкрементируемый из нескольких горутин). Убедитесь, что умеете обнаруживать и предотвращать гонки данных (race conditions) — попробуйте запустить `go run -race` на своих примерах.

**Самостоятельные задачи:** Решите несколько простых задач на конкурентность (можно найти в разделе “Concurrency” на Go by Example или в **LeetCode** с тегом concurrency). Например, реализуйте ограниченную по буферу очередь с помощью каналов или задачу из реального собеседования: «Есть функция, вызываемая из множества горутин; как обеспечить, чтобы она выполнялась не более N горутин одновременно?» (решение – семафор или ограниченный буфер).

**Ресурсы:** Прочитайте статью на Хабре о многопоточности в Go ([Многопоточность и параллелизм в Go: Goroutines и каналы / Хабр](https://habr.com/ru/companies/mvideo/articles/778248/#:~:text=%D0%AF%D0%B7%D1%8B%D0%BA%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20Go%2C%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9%20%D1%81,%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20Goroutines%20%D0%B8%20%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D1%8B)), официальное руководство **Effective Go (Concurrency)** и примеры из

**Go by Example: Goroutines/Channels**. Видео «Go Concurrency Patterns» (Rob Pike) будет полезно для понимания идиоматических паттернов.

----

# День 1: Глубокое погружение в конкуррентность Go

Привет! Сегодня мы начинаем подготовку к собеседованию по Go, фокусируясь на конкуррентности. Я проведу тебя через все необходимые материалы и объяснения. Давай начнем!

## 1. Основы конкуррентности в Go

### Что такое конкуррентность?

Конкуррентность - это способность программы выполнять несколько задач одновременно. В Go конкуррентность реализована через горутины (goroutines) и каналы (channels), что основано на модели CSP (Communicating Sequential Processes).

### Модель CSP и философия Go

Go придерживается принципа:
> "Do not communicate by sharing memory; instead, share memory by communicating."

Это означает, что вместо использования общей памяти для коммуникации между потоками (и защиты её мьютексами), Go предлагает обмениваться данными через каналы.

## 2. Горутины (Goroutines)

### Что такое горутины?

Горутины - это легковесные потоки выполнения, управляемые планировщиком Go. Горутины гораздо легче, чем системные потоки:

- Стартовый размер стека: ~2KB (против ~1MB у потоков ОС)
- Планирование: управляется рантаймом Go, а не ОС
- Масштабируемость: можно запустить тысячи или даже миллионы горутин

### Пример создания горутины

```go
func main() {
    go sayHello() // Запуск функции в отдельной горутине
    // Основная горутина продолжит выполнение
    time.Sleep(1 * time.Second) // Чтобы увидеть результат
}

func sayHello() {
    fmt.Println("Hello from goroutine!")
}
```

## 3. Каналы (Channels)

Каналы - это механизм для коммуникации между горутинами. Они позволяют безопасно передавать данные.

### Типы каналов

- **Небуферизованные каналы**: блокируют отправителя до получения данных получателем
- **Буферизованные каналы**: имеют внутренний буфер фиксированного размера

### Пример использования каналов

```go
func main() {
    ch := make(chan string) // Создание небуферизованного канала

    go func() {
        ch <- "Hello from goroutine!" // Отправка данных в канал
    }()

    msg := <-ch // Получение данных из канала
    fmt.Println(msg)
}
```

## 4. Примитивы синхронизации

### Мьютексы (Mutex)

Мьютексы используются для защиты доступа к общим данным:

```go
var (
    counter int
    mutex   sync.Mutex
)

func increment() {
    mutex.Lock()
    defer mutex.Unlock()
    counter++
}
```

`WaitGroup` в Go используется для ожидания завершения группы горутин. Он отличается от семафора и мьютекса по назначению и способу использования. Давайте рассмотрим основные различия и примеры использования.

### WaitGroup

`WaitGroup` позволяет основной горутине ожидать завершения набора горутин. Он не управляет доступом к ресурсам, а просто синхронизирует завершение работы горутин.

#### Пример использования WaitGroup

```go
package main

import (
 "fmt"
 "sync"
 "time"
)

func main() {
 var wg sync.WaitGroup

 for i := 0; i < 5; i++ {
  wg.Add(1) // Увеличиваем счетчик горутин
  go func(i int) {
   defer wg.Done() // Уменьшаем счетчик горутин по завершении
   fmt.Printf("Горутина %d начала работу\n", i)
   time.Sleep(2 * time.Second)
   fmt.Printf("Горутина %d завершила работу\n", i)
  }(i)
 }

 wg.Wait() // Ожидаем завершения всех горутин
 fmt.Println("Все горутины завершили работу")
}
```

### Другие примитивы

1. **sync.RWMutex**: Позволяет множеству горутин читать данные одновременно, но только одной - писать
2. **sync.WaitGroup**: Позволяет ждать завершения группы горутин
3. **sync.Once**: Гарантирует однократное выполнение кода
4. **sync.Cond**: Условная переменная для ожидания события

## 5. Практические примеры

### Пример 1: Конкурентное вычисление суммы элементов массива

```go
func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    numGoroutines := 2

    // Разделим массив на части
    chunkSize := len(arr) / numGoroutines

    // Канал для сбора результатов
    resultChan := make(chan int)

    // Запускаем горутины для вычисления суммы частей
    for i := 0; i < numGoroutines; i++ {
        start := i * chunkSize
        end := start + chunkSize
        if i == numGoroutines-1 {
            end = len(arr) // Последний кусок может быть больше
        }

        go func(slice []int) {
            sum := 0
            for _, num := range slice {
                sum += num
            }
            resultChan <- sum
        }(arr[start:end])
    }

    // Собираем результаты
    totalSum := 0
    for i := 0; i < numGoroutines; i++ {
        totalSum += <-resultChan
    }

    fmt.Println("Total sum:", totalSum)
}
```

### Пример 2: Producer-Consumer с буферизованным каналом

```go
func main() {
    // Буферизованный канал с емкостью 5
    jobs := make(chan int, 5)
    results := make(chan int, 5)

    // Запускаем 3 воркера
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    // Отправляем 10 задач
    for j := 1; j <= 10; j++ {
        jobs <- j
    }
    close(jobs) // Больше задач не будет

    // Получаем все результаты
    for a := 1; a <= 10; a++ {
        <-results
    }
}

func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("Worker %d started job %d\n", id, j)
        time.Sleep(time.Second) // Имитация работы
        fmt.Printf("Worker %d finished job %d\n", id, j)
        results <- j * 2
    }
}
```

### Пример 3: Использование мьютекса для защиты счетчика

```go
func main() {
    var (
        counter int
        mutex   sync.Mutex
        wg      sync.WaitGroup
    )

    // Запускаем 1000 горутин
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mutex.Lock()
            counter++
            mutex.Unlock()
        }()
    }

    wg.Wait()
    fmt.Println("Counter:", counter) // Всегда будет 1000
}
```

## 6. Семафор на каналах

```go
// Реализация семафора на основе каналов
type Semaphore chan struct{}

// Создание нового семафора с ограничением N одновременных горутин
func NewSemaphore(n int) Semaphore {
    return make(Semaphore, n)
}

// Захват семафора
func (s Semaphore) Acquire() {
    s <- struct{}{}
}

// Освобождение семафора
func (s Semaphore) Release() {
    <-s
}

// Пример использования
func main() {
    const (
        numTasks      = 100
        maxConcurrent = 3
    )

    sem := NewSemaphore(maxConcurrent)
    var wg sync.WaitGroup

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()

            sem.Acquire() // Захватываем семафор
            defer sem.Release() // Освобождаем семафор после выполнения

            fmt.Printf("Task %d starting\n", id)
            time.Sleep(100 * time.Millisecond) // Имитация работы
            fmt.Printf("Task %d completed\n", id)
        }(i)
    }

    wg.Wait()
    fmt.Println("All tasks completed")
}
```

### Основные различия

1. **Назначение**:
   - **WaitGroup**: Синхронизирует завершение группы горутин.
   - **Семафор**: Управляет доступом к ограниченному ресурсу, контролируя количество одновременно работающих горутин.
   - **Мьютекс**: Защищает критические секции кода или общие данные, разрешая доступ только одной горутине в любой момент времени.

2. **Семантика**:
   - **WaitGroup**: Используется для ожидания завершения горутин.
   - **Семафор**: Используется для ограничения количества одновременно работающих горутин или доступа к пулу ресурсов.
   - **Мьютекс**: Используется для блокировки и разблокировки доступа к критическим секциям кода или общим данным.

3. **Поведение**:
   - **WaitGroup**: Увеличивает счетчик при запуске горутины и уменьшает его по завершении. Основная горутина блокируется до тех пор, пока счетчик не станет равен нулю.
   - **Семафор**: Счетчик увеличивается и уменьшается при захвате и освобождении ресурса.
   - **Мьютекс**: Блокирует и разблокирует доступ к критической секции кода или общим данным.

### Примеры использования

- **WaitGroup**: Ожидание завершения набора горутин, например, при выполнении параллельных задач, после которых нужно выполнить финальную операцию.
- **Семафор**: Ограничение количества одновременно работающих горутин, например, при работе с пулом соединений к базе данных.
- **Мьютекс**: Защита критических секций кода или общих данных, например, при инкрементировании общего счетчика.

Таким образом, `WaitGroup`, семафор и мьютекс имеют разные назначения и используются в разных сценариях для синхронизации горутин и управления доступом к ресурсам.

## Проверка на гонки данных (race conditions)

Запустите ваши программы с флагом `-race`:

```bash
go run -race your_program.go
```

Это поможет обнаружить потенциальные гонки данных.

## Дополнительные ресурсы для изучения

1. [Многопоточность и параллелизм в Go: Goroutines и каналы](https://habr.com/ru/companies/mvideo/articles/778248/)
2. [Effective Go: Concurrency](https://golang.org/doc/effective_go#concurrency)
3. [Go by Example: Goroutines](https://gobyexample.com/goroutines)
4. [Go by Example: Channels](https://gobyexample.com/channels)
5. [Go Concurrency Patterns (Rob Pike)](https://www.youtube.com/watch?v=f6kdp27TYZs)
